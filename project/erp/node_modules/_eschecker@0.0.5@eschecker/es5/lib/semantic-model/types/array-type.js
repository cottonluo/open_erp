"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ArrayType = undefined;

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _recordType = require("./record-type");

var _type = require("./type");

var _numberType = require("./number-type");

var _voidType = require("./void-type");

var _maybeType = require("./maybe-type");

var _functionType = require("./function-type");

var _booleanType = require("./boolean-type");

var _stringType = require("./string-type");

var _typeVariable = require("./type-variable");

var _symbol = require("../symbol");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const builtIns = new Set(["length", "concat", "copyWithin", "every", "fill", "filter", "find", "findIndex", "forEach", "includes", "indexOf", "join", "lastIndexOf", "map", "pop", "push", "reduce", "reduceRight", "reverse", "shift", "slice", "some", "sort", "splice", "unshift"]);

/**
 * Array type.
 *
 * The array type is a parametrised and a record type. The array type accepts the type argument T that defines the type of
 * the array elements. If an array contains elements from different types, then the type T is any.
 */
class ArrayType extends _recordType.RecordType {

	static of(t) {
		return new ArrayType(t);
	}

	/**
  * Creates a new array type that contains element of type of.
  * @param {Type} of the type of the array elements
  * @param {Immutable.Map.<Member, Type>} [properties] the additional properties of this array
  * @param [id] the id of the instance
     */
	constructor(of, properties, id) {
		(0, _assert2.default)(of instanceof _type.Type, "Of needs to be a type");
		super(properties, id);

		this.of = of;
	}

	get prettyName() {
		return `${ this.of }[]`;
	}

	isSubType(t) {
		if (!super.isSubType(t)) {
			return false;
		}

		return this.of.isSubType(t.of);
	}

	substitute(oldType, newType) {
		if (this.same(oldType)) {
			return newType;
		}

		const substitutedOf = this.of.substitute(oldType, newType);

		if (this.of !== substitutedOf) {
			return new ArrayType(substitutedOf, this.properties, this.id);
		}

		return super.substitute(oldType, newType);
	}

	containsType(t) {
		return super.containsType(t) || this.of.containsType(t);
	}

	equals(other) {
		if (!super.equals(other)) {
			return false;
		}

		return this.of.equals(other.of);
	}

	hasProperty(symbol) {
		if ((symbol.flags & _symbol.SymbolFlags.Computed) === _symbol.SymbolFlags.Computed || typeof symbol.name === "number") {
			return true;
		}

		return builtIns.has(symbol.name) || super.hasProperty(symbol);
	}

	getType(symbol) {
		if ((symbol.flags & _symbol.SymbolFlags.Computed) === _symbol.SymbolFlags.Computed || typeof symbol.name === "number") {
			return this.of;
		}

		if (builtIns.has(symbol.name)) {
			return this._getBuiltInType(symbol.name);
		}

		return super.getType(symbol);
	}

	_getBuiltInType(name) {
		const maybeArray = _maybeType.MaybeType.of(this);
		const callbackThis = new _typeVariable.TypeVariable();
		const callbackThisArg = _maybeType.MaybeType.of(callbackThis);
		const predicateT = new _functionType.FunctionType(callbackThis, [this.of, _numberType.NumberType.create(), this], _booleanType.BooleanType.create());

		switch (name) {
			case "length":
				return _numberType.NumberType.create();
			case "concat":
				return new _functionType.FunctionType(this, [this, maybeArray, maybeArray], this);
			case "copyWithin":
				return new _functionType.FunctionType(this, [_numberType.NumberType.create(), _numberType.NumberType.create(), _maybeType.MaybeType.of(_numberType.NumberType.create())], _voidType.VoidType.create());
			case "every":
			case "some":
				return new _functionType.FunctionType(this, [predicateT, callbackThisArg], _booleanType.BooleanType.create());
			case "filter":
				return new _functionType.FunctionType(this, [predicateT, callbackThisArg], this);
			case "fill":
				return new _functionType.FunctionType(this, [this.of, _numberType.NumberType.create(), _numberType.NumberType.create()], _voidType.VoidType.create());
			case "find":
				return new _functionType.FunctionType(this, [predicateT, callbackThisArg], this.of);
			case "findIndex":
				return new _functionType.FunctionType(this, [predicateT, callbackThisArg], _numberType.NumberType.create());
			case "forEach":
				return new _functionType.FunctionType(this, [new _functionType.FunctionType(callbackThis, [this.of, _numberType.NumberType.create(), this], _voidType.VoidType.create()), callbackThisArg], _voidType.VoidType.create());
			case "includes":
				return new _functionType.FunctionType(this, [this.of, _maybeType.MaybeType.of(_numberType.NumberType.create())], _booleanType.BooleanType.create());
			case "lastIndexOf":
			case "indexOf":
				return new _functionType.FunctionType(this, [this.of, _maybeType.MaybeType.of(_numberType.NumberType.create())], _numberType.NumberType.create());
			case "map":
				var mapReturnType = new _typeVariable.TypeVariable();
				return new _functionType.FunctionType(this, [new _functionType.FunctionType(callbackThis, [this.of, _numberType.NumberType.create(), this], mapReturnType), callbackThisArg], ArrayType.of(mapReturnType));
			case "join":
				return new _functionType.FunctionType(this, [_maybeType.MaybeType.of(_stringType.StringType.create())], _stringType.StringType.create());
			case "pop":
			case "shift":
				return new _functionType.FunctionType(this, [], this.of);
			case "push":
			case "unshift":
				return new _functionType.FunctionType(this, [this.of], _numberType.NumberType.create());
			case "reduce":
			case "reduceRight":
				var reduceValue = new _typeVariable.TypeVariable();
				return new _functionType.FunctionType(this, [new _functionType.FunctionType(_voidType.VoidType.create(), [reduceValue, this.of, _numberType.NumberType.create(), this], reduceValue), _maybeType.MaybeType.of(reduceValue)], reduceValue);
			case "reverse":
				return new _functionType.FunctionType(this, [], this);
			case "slice":
				return new _functionType.FunctionType(this, [_numberType.NumberType.create(), _maybeType.MaybeType.of(_numberType.NumberType.create())], this);
			case "sort":
				return new _functionType.FunctionType(this, [_maybeType.MaybeType.of(new _functionType.FunctionType(_voidType.VoidType.create(), [this.of, this.of], _numberType.NumberType.create()))], this);
			default:
				_assert2.default.fail(`${ name } is not a built in array function`);
		}
	}

	setType(symbol, type) {
		(0, _assert2.default)(!builtIns.has(symbol.name), `The type of the built in array property '${ symbol.name }' cannot be changed`);

		if ((symbol.flags & _symbol.SymbolFlags.Computed) === _symbol.SymbolFlags.Computed || typeof symbol.name === "number") {
			return new ArrayType(type, this.properties, this.id);
		}

		return super.setType(symbol, type);
	}

	withProperties(properties, id) {
		return new ArrayType(this.of, properties, id);
	}
}

exports.ArrayType = ArrayType;
exports.default = ArrayType;
//# sourceMappingURL=array-type.js.map
