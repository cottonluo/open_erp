"use strict";

var _chai = require("chai");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

describe("MaybeType", function () {
	it("of contains the type parameter", function () {
		// arrange
		const number = new _types.Type("number");

		// act
		const maybe = _types.MaybeType.of(number);

		// assert
		(0, _chai.expect)(maybe.of).to.equal(number);
	});

	describe("typeParameters", function () {
		it("returns an array containing the of type", function () {
			// arrange
			const number = new _types.Type("number");

			// act
			const maybe = _types.MaybeType.of(number);

			// assert
			(0, _chai.expect)(maybe.typeParameters).to.deep.equal([number]);
		});
	});

	describe("withTypeParameters", function () {
		it("returns a new instance with the specified id", function () {
			// arrange
			const maybe = _types.MaybeType.of(new _types.Type("number"));

			// act
			const newMaybe = maybe.withTypeParameters([new _types.Type("string")], maybe.id);

			// assert
			(0, _chai.expect)(newMaybe).not.to.be.equal(maybe);
			(0, _chai.expect)(newMaybe.id).to.be.equal(maybe.id);
		});

		it("is a maybe of the new type parameter", function () {
			// arrange
			const maybe = _types.MaybeType.of(new _types.Type("string"));
			const number = new _types.Type("number");

			// act
			const newMaybe = maybe.withTypeParameters([number]);

			// assert
			(0, _chai.expect)(newMaybe.of).to.equal(number);
		});
	});

	describe("isSubType", function () {
		it("returns true for Maybe<T>.isSubType(Maybe<T>)", function () {
			// arrange
			const maybe1 = _types.MaybeType.of(_types.NumberType.create());
			const maybe2 = _types.MaybeType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(maybe1.isSubType(maybe2)).to.be.true;
		});

		it("returns true for Maybe<T> and Maybe<S> where S is subtype of T", function () {
			// arrange
			const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
			const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Property);
			const maybe1 = _types.MaybeType.of(_types.ObjectType.create([[name, _types.StringType.create()]]));
			const maybe2 = _types.MaybeType.of(_types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]));

			// act, assert
			(0, _chai.expect)(maybe1.isSubType(maybe2)).to.be.true;
		});

		it("returns false for Maybe<T> and Maybe<S> where S is NOT a subtype of T", function () {
			// arrange
			const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
			const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Property);
			const maybe1 = _types.MaybeType.of(_types.ObjectType.create([[name, _types.StringType.create()]]));
			const maybe2 = _types.MaybeType.of(_types.ObjectType.create([[age, _types.NumberType.create()]]));

			// act, assert
			(0, _chai.expect)(maybe1.isSubType(maybe2)).to.be.false;
		});

		it("returns true for null", function () {
			(0, _chai.expect)(_types.MaybeType.of(_types.StringType.create()).isSubType(_types.NullType.create())).to.be.true;
		});

		it("returns true for void", function () {
			(0, _chai.expect)(_types.MaybeType.of(_types.StringType.create()).isSubType(_types.VoidType.create())).to.be.true;
		});

		it("returns true for Maybe<T>.isSubType(T)", function () {
			// arrange
			const maybe1 = _types.MaybeType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(maybe1.isSubType(_types.NumberType.create())).to.be.true;
		});

		it("returns false for Maybe<T>.isSubType(U) where U is NOT a subtype of T", function () {
			// arrange
			const maybe1 = _types.MaybeType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(maybe1.isSubType(_types.StringType.create())).to.be.false;
		});
	});
});
//# sourceMappingURL=maybe-type.spec.js.map
