"use strict";

var _chai = require("chai");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _functionRefinementRule = require("../../../lib/type-inference/refinement-rules/function-refinement-rule");

var _types = require("../../../lib/semantic-model/types");

var _symbol = require("../../../lib/semantic-model/symbol");

var _controlFlowGraph = require("../../../lib/cfg/control-flow-graph");

var _edge = require("../../../lib/cfg/edge");

var _node = require("../../../lib/cfg/node");

var _program = require("../../../lib/semantic-model/program");

var _typeInferenceContext = require("../../../lib/type-inference/type-inference-context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

describe("FunctionRefinementRule", function () {
	let rule, context, cfg, program;

	beforeEach(function () {
		rule = new _functionRefinementRule.FunctionRefinementRule();
		cfg = new _controlFlowGraph.ControlFlowGraph();
		_sinon2.default.stub(cfg, "getExitEdges");

		program = new _program.Program();
		context = new _typeInferenceContext.TypeInferenceContext(program);
		_sinon2.default.stub(context, "getCfg").returns(cfg);
	});

	describe("canRefine", function () {
		it("returns true for a function declaration", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));

			// act, assert
			(0, _chai.expect)(rule.canRefine(functionDeclaration)).to.be.true;
		});

		it("returns true for an arrow function expression", function () {
			// arrange
			const arrowFunctionExpression = t.arrowFunctionExpression([], t.blockStatement([]));

			// act, assert
			(0, _chai.expect)(rule.canRefine(arrowFunctionExpression)).to.be.true;
		});

		it("returns true for a class method", function () {
			// arrange
			const classMethod = t.classMethod("method", t.identifier("x"), [], t.blockStatement([]));

			// act, assert
			(0, _chai.expect)(rule.canRefine(classMethod)).to.be.true;
		});

		it("returns true for an object method", function () {
			// arrange
			const objectMethod = t.objectMethod("method", t.identifier("x"), [], t.blockStatement([]));

			// act, assert
			(0, _chai.expect)(rule.canRefine(objectMethod)).to.be.true;
		});

		it("returns false in the other cases", function () {
			// arrange
			const identifier = t.identifier("x");

			// act, assert
			(0, _chai.expect)(rule.canRefine(identifier)).to.be.false;
		});
	});

	describe("inferFunctionType", function () {
		it("returns a FunctionType for a function declaration", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));
			cfg.getExitEdges.returns([]);

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("abcd", _symbol.SymbolFlags.Function));

			// act, assert
			(0, _chai.expect)(_functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context)).to.be.instanceOf(_types.FunctionType);
		});

		it("Sets the function type in the symbol table", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));
			cfg.getExitEdges.returns([]);

			const functionSymbol = new _symbol.Symbol("abcd", _symbol.SymbolFlags.Function);
			program.symbolTable.setSymbol(functionDeclaration, functionSymbol);

			// act
			_functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(context.getType(functionSymbol)).to.be.instanceOf(_types.FunctionType);
		});

		it("adds a type parameter for each parameter", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("multiply"), [t.identifier("x"), t.identifier("y")], t.blockStatement([]));
			const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
			const y = new _symbol.Symbol("y", _symbol.SymbolFlags.Variable);

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("multiply", _symbol.SymbolFlags.Function));
			program.symbolTable.setSymbol(functionDeclaration.params[0], x);
			program.symbolTable.setSymbol(functionDeclaration.params[1], y);

			cfg.getExitEdges.returns([]);

			// act
			const refined = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(refined.thisType).to.be.instanceOf(_types.TypeVariable); // will be changed when the this parameter will be implemented
			(0, _chai.expect)(refined.params[0]).to.be.instanceOf(_types.TypeVariable);
			(0, _chai.expect)(refined.params[1]).to.be.instanceOf(_types.TypeVariable);
		});

		it("sets the return type to void if no exit edge is an explicit return statement", function () {
			// arrange
			const statement = t.expressionStatement(t.assignmentExpression("=", t.identifier("x"), t.identifier("y")));
			const functionDeclaration = t.functionDeclaration(t.identifier("multiply"), [t.identifier("x"), t.identifier("y")], t.blockStatement([statement]));

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("multiply", _symbol.SymbolFlags.Function));
			program.symbolTable.setSymbol(functionDeclaration.params[0], new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));
			program.symbolTable.setSymbol(functionDeclaration.params[1], new _symbol.Symbol("y", _symbol.SymbolFlags.Variable));

			const exit1 = new _edge.Edge(new _node.Node(statement), _controlFlowGraph.BRANCHES.UNCONDITIONAL, new _node.Node(null));
			cfg.getExitEdges.returns([exit1]);

			// act
			const refined = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(refined.returnType).to.be.instanceOf(_types.VoidType);
		});

		it("sets the return type to a type variable if the function has one explicit return edge", function () {
			// arrange
			const statement = t.returnStatement(t.binaryExpression("*", t.identifier("x"), t.identifier("y")));
			const functionDeclaration = t.functionDeclaration(t.identifier("multiply"), [t.identifier("x"), t.identifier("y")], t.blockStatement([statement]));

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("multiply", _symbol.SymbolFlags.Function));
			program.symbolTable.setSymbol(functionDeclaration.params[0], new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));
			program.symbolTable.setSymbol(functionDeclaration.params[1], new _symbol.Symbol("y", _symbol.SymbolFlags.Variable));

			const exit1 = new _edge.Edge(new _node.Node(statement), _controlFlowGraph.BRANCHES.UNCONDITIONAL, new _node.Node(null));
			cfg.getExitEdges.returns([exit1]);

			// act
			const refined = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(refined.returnType).to.be.instanceOf(_types.TypeVariable);
		});

		it("sets the return type to a type variable if all exit nodes are explicit returns or EXCEPTION Branches", function () {
			// arrange
			const statement = t.returnStatement(t.binaryExpression("*", t.identifier("x"), t.identifier("y")));
			const throwExit = t.throwStatement(t.identifier("z"));
			const functionDeclaration = t.functionDeclaration(t.identifier("multiply"), [t.identifier("x"), t.identifier("y")], t.blockStatement([statement]));

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("multiply", _symbol.SymbolFlags.Function));
			program.symbolTable.setSymbol(functionDeclaration.params[0], new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));
			program.symbolTable.setSymbol(functionDeclaration.params[1], new _symbol.Symbol("y", _symbol.SymbolFlags.Variable));

			const exit1 = new _edge.Edge(new _node.Node(statement), _controlFlowGraph.BRANCHES.UNCONDITIONAL, new _node.Node(null));
			const throwEdge = new _edge.Edge(new _node.Node(throwExit), _controlFlowGraph.BRANCHES.EXCEPTION, new _node.Node(null));
			cfg.getExitEdges.returns([exit1, throwEdge]);

			// act
			const refined = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(refined.returnType).to.be.instanceOf(_types.TypeVariable);
		});

		it("sets the return type to void type if the function has one non explicit return edge (in this case the function might return a value)", function () {
			// arrange
			const statement = t.returnStatement(t.binaryExpression("*", t.identifier("x"), t.identifier("y")));
			const otherExit = t.expressionStatement(t.binaryExpression("*", t.identifier("x"), t.identifier("y")));
			const functionDeclaration = t.functionDeclaration(t.identifier("multiply"), [t.identifier("x"), t.identifier("y")], t.blockStatement([statement]));

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("multiply", _symbol.SymbolFlags.Function));
			program.symbolTable.setSymbol(functionDeclaration.params[0], new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));
			program.symbolTable.setSymbol(functionDeclaration.params[1], new _symbol.Symbol("y", _symbol.SymbolFlags.Variable));

			const exit1 = new _edge.Edge(new _node.Node(statement), _controlFlowGraph.BRANCHES.UNCONDITIONAL, new _node.Node(null));
			const exit2 = new _edge.Edge(new _node.Node(otherExit), _controlFlowGraph.BRANCHES.UNCONDITIONAL, new _node.Node(null));
			cfg.getExitEdges.returns([exit1, exit2]);

			// act
			const refined = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(refined.returnType).to.be.instanceOf(_types.VoidType);
		});

		it("sets the function declaration node", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));
			cfg.getExitEdges.returns([]);

			program.symbolTable.setSymbol(functionDeclaration, new _symbol.Symbol("abcd", _symbol.SymbolFlags.Function));

			// act
			const func = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(functionDeclaration, context);

			// assert
			(0, _chai.expect)(func.declaration).to.equal(functionDeclaration);
		});

		it("uses a type variable if the function declaration body is an expression", function () {
			// arrange
			const arrowFunction = t.arrowFunctionExpression([], t.identifier("x"));
			arrowFunction.expression = true;
			program.symbolTable.setSymbol(arrowFunction, new _symbol.Symbol("anonymous function 1"));

			// act
			const func = _functionRefinementRule.FunctionRefinementRule.inferFunctionType(arrowFunction, context);

			// assert
			(0, _chai.expect)(func.returnType).to.be.instanceOf(_types.TypeVariable);
		});
	});

	describe("refine", function () {
		it("sets the type environment of the declaration in the function type", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));
			const functionT = new _types.FunctionType(_types.TypeVariable.create(), [], _types.TypeVariable.create());
			const abcd = new _symbol.Symbol("abcd", _symbol.SymbolFlags.Function);
			cfg.getExitEdges.returns([]);

			program.symbolTable.setSymbol(functionDeclaration, abcd);
			context.setType(abcd, functionT);

			// act
			const func = rule.refine(functionDeclaration, context);

			// assert
			(0, _chai.expect)(func.typeEnvironment).to.equal(context.typeEnvironment);
		});

		it("resolves the type of a function declaration from the context", function () {
			// arrange
			const functionDeclaration = t.functionDeclaration(t.identifier("abcd"), [], t.blockStatement([]));
			const functionT = new _types.FunctionType(_types.TypeVariable.create(), [], _types.TypeVariable.create());
			const abcd = new _symbol.Symbol("abcd", _symbol.SymbolFlags.Function);

			cfg.getExitEdges.returns([]);

			program.symbolTable.setSymbol(functionDeclaration, abcd);
			context.setType(abcd, functionT);

			// act
			const func = rule.refine(functionDeclaration, context);

			// assert
			(0, _chai.expect)(func).to.equal(functionT);
		});

		it("infers the type of a function expression", function () {
			// arrange
			const functionExpression = t.functionExpression(null, [], t.blockStatement([]));
			cfg.getExitEdges.returns([]);

			program.symbolTable.setSymbol(functionExpression, new _symbol.Symbol("anonymous"));

			// act
			const func = rule.refine(functionExpression, context);

			// assert
			(0, _chai.expect)(func).not.to.be.undefined;
			(0, _chai.expect)(func.returnType).to.be.instanceOf(_types.VoidType);
		});
	});
});
//# sourceMappingURL=function-refinement-rule.spec.js.map
