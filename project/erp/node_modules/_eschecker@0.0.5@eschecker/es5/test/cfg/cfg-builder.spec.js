"use strict";

var _babylon = require("babylon");

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _chai = require("chai");

var _controlFlowGraph = require("../../lib/cfg/control-flow-graph");

var _cfgBuilder = require("../../lib/cfg/cfg-builder");

var _cfgBuilder2 = _interopRequireDefault(_cfgBuilder);

var _util = require("../../lib/util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("CfgBuilder", function () {
	it("returns a cfg", function () {
		// act

		var _toCfg = toCfg("");

		const cfg = _toCfg.cfg;

		// assert

		(0, _chai.expect)(cfg).not.to.be.null;
	});

	describe("ExpressionStatement", function () {
		it("creates an edge to the successor node", () => {
			// act

			var _toCfg2 = toCfg("x++;");

			const ast = _toCfg2.ast;
			const cfg = _toCfg2.cfg;

			// assert

			const expression = ast.program.body[0];
			(0, _chai.expect)(cfg.isConnected(expression, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("VariableDeclaration", function () {
		it("creates an edge to the successor node", () => {
			var _toCfg3 = toCfg("let x = 10;");

			const ast = _toCfg3.ast;
			const cfg = _toCfg3.cfg;

			// assert

			const variableDeclaration = ast.program.body[0];
			(0, _chai.expect)(cfg.isConnected(variableDeclaration, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("EmptyStatement", function () {
		it("skips an empty statement", () => {
			var _toCfg4 = toCfg("let x = 10;;x++");

			const ast = _toCfg4.ast;
			const cfg = _toCfg4.cfg;

			// assert

			const declaration = ast.program.body[0];
			const emptyStatement = ast.program.body[1];
			const update = ast.program.body[2];
			(0, _chai.expect)(cfg.getNode(emptyStatement)).to.be.undefined;
			(0, _chai.expect)(cfg.isConnected(declaration, update, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("BreakStatement", function () {
		it("creates an edge to the successor statement of the parent loop statement", () => {
			var _toCfg5 = toCfg(`
				for (let i = 0; i < 10; ++i) {
					if (y) {
						break;
					}
					console.log(y);
				}
			`);

			const ast = _toCfg5.ast;
			const cfg = _toCfg5.cfg;

			// assert

			const breakStatement = ast.program.body[0].body.body[0].consequent.body[0];
			(0, _chai.expect)(cfg.isConnected(breakStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("fails if a break statement is used inside of try finally", function () {
			(0, _chai.expect)(() => toCfg(`
			while(true) {
				try {
					break;
				} finally {
					console.log("A");
				}
			}
			`)).to.throw();
		});
	});

	describe("ContinueStatement", function () {
		it("creates an edge to the direct parent loop statement", () => {
			var _toCfg6 = toCfg(`
			for (let i = 0; i < 10; ++i) {
				if (y) {
					continue;
				}
				console.log(y);
			}
			`);

			const ast = _toCfg6.ast;
			const cfg = _toCfg6.cfg;

			// assert

			const forLoop = ast.program.body[0];
			const continueStatement = forLoop.body.body[0].consequent.body[0];
			(0, _chai.expect)(cfg.isConnected(continueStatement, forLoop, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("fails if a continue statement is used inside of try finally", function () {
			(0, _chai.expect)(() => toCfg(`
			while (true) {
				try {
					continue;
				} finally {
					console.log("A");
				}
			}
			`)).to.throw();
		});
	});

	describe("BlockStatement", function () {
		it("connects the first statement in the block statement as successor node", () => {
			var _toCfg7 = toCfg(`
			{
				const x = 10;
			}
			`);

			const ast = _toCfg7.ast;
			const cfg = _toCfg7.cfg;

			// assert

			const blockStatement = ast.program.body[0];
			const assignment = blockStatement.body[0];
			(0, _chai.expect)(cfg.isConnected(blockStatement, assignment, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the block statement with a function declaration, if the function declaration is the first statement in the block", function () {
			var _toCfg8 = toCfg(`
			{
				function hy () {
					console.log("Hello world");
				}
				const x = 10;
			}
			`);

			const ast = _toCfg8.ast;
			const cfg = _toCfg8.cfg;

			// assert

			const blockStatement = ast.program.body[0];
			const functionDeclaration = blockStatement.body[0];
			(0, _chai.expect)(cfg.isConnected(blockStatement, functionDeclaration, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the next sibling of the block statement as successor if the block statement is empty", () => {
			var _toCfg9 = toCfg(`
			{
			}
			const x = 10;
			`);

			const ast = _toCfg9.ast;
			const cfg = _toCfg9.cfg;

			// assert

			const blockStatement = ast.program.body[0];
			const assignment = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(blockStatement, assignment, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("IfStatement", function () {
		it("creates a conditional false branch from the if statement to following sibling node if the if statement has no else branch", function () {
			// act

			var _toCfg10 = toCfg(`
			let x = 0;
			if (x < 10) {
				x = 9;
			}
			`);

			const ast = _toCfg10.ast;
			const cfg = _toCfg10.cfg;

			// assert

			const ifStatement = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(ifStatement, null, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("creates a conditional true branch from the if statement to the consequent body", function () {
			// act

			var _toCfg11 = toCfg(`
			let x = 0;
			if (x < 10) {
				x = 9;
			}
			`);

			const ast = _toCfg11.ast;
			const cfg = _toCfg11.cfg;

			// assert

			const ifStatement = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(ifStatement, ifStatement.consequent, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("creates an unconditional branch from the last statement in the consequent to successor of the if statement", function () {
			// act

			var _toCfg12 = toCfg(`
			let x = 0;
			if (x < 10) {
				x = 9;
			}
			`);

			const ast = _toCfg12.ast;
			const cfg = _toCfg12.cfg;

			// assert

			const ifStatement = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(ifStatement.consequent.body[0], null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("creates a conditional false branch from the if statement to the else branch for an if statement with an else branch", function () {
			// act

			var _toCfg13 = toCfg(`
			let x = 0;
			if (x < 10) {
				x = 9;
			} else {
				x = 8;
			}
			`);

			const ast = _toCfg13.ast;
			const cfg = _toCfg13.cfg;

			// assert

			const ifStatement = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(ifStatement, ifStatement.alternate, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
			(0, _chai.expect)(cfg.isConnected(ifStatement, null)).to.be.false;
		});

		it("creates an unconditional branch from the last statement in the alternate to the successor of the if statement", function () {
			// act

			var _toCfg14 = toCfg(`
			let x = 0;
			if (x < 10) {
				x = 9;
			} else {
				x = 8;
			}
			`);

			const ast = _toCfg14.ast;
			const cfg = _toCfg14.cfg;

			// assert

			const ifStatement = ast.program.body[1];
			(0, _chai.expect)(cfg.isConnected(ifStatement.alternate.body[0], null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("WhileStatement", function () {
		it("connects the first statement in the while statement as successor (TRUE Branch)", () => {
			var _toCfg15 = toCfg(`
			while (x < 10) {
				++x;
			}
			`);

			const ast = _toCfg15.ast;
			const cfg = _toCfg15.cfg;

			// assert

			const whileStatement = ast.program.body[0];
			const blockStatement = whileStatement.body;

			(0, _chai.expect)(cfg.isConnected(whileStatement, blockStatement, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the successor of the while statement with a false branch", () => {
			var _toCfg16 = toCfg(`
			while (x < 10) {
				++x;
			}
			`);

			const ast = _toCfg16.ast;
			const cfg = _toCfg16.cfg;

			// assert

			const whileStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(whileStatement, null, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});
	});

	describe("ForStatement", function () {
		it("connects the init statement with the for statement (which represents the condition)", () => {
			var _toCfg17 = toCfg(`
			for (let x = 0; x < 10; ++x) {
				console.log(x);
			}
			`);

			const ast = _toCfg17.ast;
			const cfg = _toCfg17.cfg;

			// assert

			const forStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forStatement.init, forStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the body statement of the for loop as successor of the for loop itself (TRUE Branch)", () => {
			var _toCfg18 = toCfg(`
			for (let x = 0; x < 10; ++x) {
				console.log(x);
			}
			`);

			const ast = _toCfg18.ast;
			const cfg = _toCfg18.cfg;

			// assert

			const forStatement = ast.program.body[0];
			const blockStatement = forStatement.body;

			(0, _chai.expect)(cfg.isConnected(forStatement, blockStatement, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the update statement as successor of the last statement in the body of the for loop", () => {
			var _toCfg19 = toCfg(`
			for (let x = 0; x < 10; ++x) {
				console.log(x);
			}
			`);

			const ast = _toCfg19.ast;
			const cfg = _toCfg19.cfg;

			// assert

			const forStatement = ast.program.body[0];
			const assignmentStatement = forStatement.body.body[0];

			(0, _chai.expect)(cfg.isConnected(assignmentStatement, forStatement.update, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the for statement with the successor of the for statement (FALSE)", () => {
			var _toCfg20 = toCfg(`
			for (let x = 0; x < 10; ++x) {
				console.log(x);
			}
			`);

			const ast = _toCfg20.ast;
			const cfg = _toCfg20.cfg;

			// assert

			const forStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forStatement, null, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("connects the last statement in the loop directly with the for statement and not with the update statement, if the for statement has no update statement", () => {
			var _toCfg21 = toCfg(`
			for (;;) {
				console.log(x);
			}
			`);

			const ast = _toCfg21.ast;
			const cfg = _toCfg21.cfg;

			// assert

			const forStatement = ast.program.body[0];
			const expressionStatement = forStatement.body.body[0];

			(0, _chai.expect)(cfg.isConnected(expressionStatement, forStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
			(0, _chai.expect)(cfg.isConnected(expressionStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
		});

		it("does not connect the successor of the for statement as false branch of the for statement if the for statement has no condition and therefore is always true", () => {
			var _toCfg22 = toCfg(`
			for (;;) {
				console.log(x);
			}
			x = 10;
			`);

			const ast = _toCfg22.ast;
			const cfg = _toCfg22.cfg;

			// assert

			const forStatement = ast.program.body[0];
			const assignment = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(forStatement, assignment, _controlFlowGraph.BRANCHES.FALSE)).to.be.false;
		});

		it("does not connect the for statement init statement (null) with the for statement if the for statement has no init statement and therefore is null (EOF)", () => {
			var _toCfg23 = toCfg(`
			for (;;x++) {
				console.log(x);
			}
			x = 10;
			`);

			const ast = _toCfg23.ast;
			const cfg = _toCfg23.cfg;

			// assert

			const forStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forStatement.init, forStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
		});

		it("does not connect the ForStatement update (null) with the for statement if the for statement has no update statement and therefore is null (EOF)", () => {
			var _toCfg24 = toCfg(`
			for (let y = 0; y < 10;) {
				console.log(x);
			}
			x = 10;
			`);

			const ast = _toCfg24.ast;
			const cfg = _toCfg24.cfg;

			// assert

			const forStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forStatement.update, forStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
		});
	});

	describe("ForInStatement", function () {
		it("connects the for statement with a true branch to it's body", () => {
			var _toCfg25 = toCfg(`
			for (let p in o) {
				console.log(p);
			}
			`);

			const ast = _toCfg25.ast;
			const cfg = _toCfg25.cfg;

			// assert

			const forInStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forInStatement, forInStatement.body, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the for statement with a false branch to it's successor", () => {
			var _toCfg26 = toCfg(`
			for (let p in o) {
				console.log(p);
			}
			console.log("end");
			`);

			const ast = _toCfg26.ast;
			const cfg = _toCfg26.cfg;

			// assert

			const forInStatement = ast.program.body[0];
			const endStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(forInStatement, endStatement, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});
	});

	describe("ForOfStatement", function () {
		it("connects the for statement with a true branch to it's body", () => {
			var _toCfg27 = toCfg(`
			for (let p of o) {
				console.log(p);
			}
			`);

			const ast = _toCfg27.ast;
			const cfg = _toCfg27.cfg;

			// assert

			const forOfStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(forOfStatement, forOfStatement.body, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the for statement with a false branch to it's successor", () => {
			var _toCfg28 = toCfg(`
			for (let p of o) {
				console.log(p);
			}
			console.log("end");
			`);

			const ast = _toCfg28.ast;
			const cfg = _toCfg28.cfg;

			// assert

			const forOfStatement = ast.program.body[0];
			const endStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(forOfStatement, endStatement, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});
	});

	describe("DoWhileStatement", function () {
		it("connects the do while statement with a true branch to it's body", () => {
			var _toCfg29 = toCfg(`
			do {
				console.log(p++);
			} while (p < 10);
			`);

			const ast = _toCfg29.ast;
			const cfg = _toCfg29.cfg;

			// assert

			const doWhileStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(doWhileStatement, doWhileStatement.body, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the do while statement with a false branch to it's successor", () => {
			var _toCfg30 = toCfg(`
			do {
				console.log(p++);
			} while (p < 10);
			console.log("end");
			`);

			const ast = _toCfg30.ast;
			const cfg = _toCfg30.cfg;

			// assert

			const doWhileStatement = ast.program.body[0];
			const endStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(doWhileStatement, endStatement, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});
	});

	describe("SwitchStatement", function () {
		it("connects the switch statement with the first case statement", () => {
			var _toCfg31 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
			}
			`);

			const ast = _toCfg31.ast;
			const cfg = _toCfg31.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];

			(0, _chai.expect)(cfg.isConnected(switchStatement, firstCase, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the switch statement with the first case statement even when the default statement is first in order", () => {
			var _toCfg32 = toCfg(`
			switch (x) {
				default:
					y = null;
				case "A":
					y = 2;
			}
			`);

			const ast = _toCfg32.ast;
			const cfg = _toCfg32.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const defaultStatement = switchStatement.cases[0];
			const firstCase = switchStatement.cases[1];

			(0, _chai.expect)(cfg.isConnected(switchStatement, defaultStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
			(0, _chai.expect)(cfg.isConnected(switchStatement, firstCase, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the switch statement with it's successor and not with null (first case) if the switch statement has no cases", () => {
			var _toCfg33 = toCfg(`
			switch (x) {
			}
			
			console.log(x);
			`);

			const ast = _toCfg33.ast;
			const cfg = _toCfg33.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const logStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(switchStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
			(0, _chai.expect)(cfg.isConnected(switchStatement, logStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("SwitchCase", function () {
		it("connects the case with a true branch to it's consequent", () => {
			var _toCfg34 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
			}
			`);

			const ast = _toCfg34.ast;
			const cfg = _toCfg34.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];

			(0, _chai.expect)(cfg.isConnected(firstCase, firstCase.consequent[0], _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the case with a false branch to the next case", () => {
			var _toCfg35 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
			}
			`);

			const ast = _toCfg35.ast;
			const cfg = _toCfg35.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];
			const defaultCase = switchStatement.cases[1];

			(0, _chai.expect)(cfg.isConnected(firstCase, defaultCase, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("connects the case with a false branch to the successor of the switch statement if it is the last case in the switch", () => {
			var _toCfg36 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
			}
			console.log("A");
			`);

			const ast = _toCfg36.ast;
			const cfg = _toCfg36.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const caseA = switchStatement.cases[0];
			const logStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(caseA, logStatement, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("connects the case with a false branch to the next case even when default is the next 'case' in order", () => {
			var _toCfg37 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
				case "B":
					y = 3;
			}
			`);

			const ast = _toCfg37.ast;
			const cfg = _toCfg37.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];
			const defaultCase = switchStatement.cases[1];
			const secondCase = switchStatement.cases[2];

			(0, _chai.expect)(cfg.isConnected(firstCase, defaultCase, _controlFlowGraph.BRANCHES.FALSE)).to.be.false;
			(0, _chai.expect)(cfg.isConnected(firstCase, secondCase, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("connects the case with a false branch to the default case the case is the last in order", () => {
			var _toCfg38 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
				case "B":
					y = 3;
			}
			`);

			const ast = _toCfg38.ast;
			const cfg = _toCfg38.cfg;

			// assert

			const switchStatement = ast.program.body[0];

			const defaultCase = switchStatement.cases[1];
			const secondCase = switchStatement.cases[2];

			(0, _chai.expect)(cfg.isConnected(secondCase, defaultCase, _controlFlowGraph.BRANCHES.FALSE)).to.be.true;
		});

		it("connects the default case consequent with an unconditional branch", () => {
			var _toCfg39 = toCfg(`
			switch (x) {
				case "A":
					y = 2;
				default:
					y = null;
			}
			`);

			const ast = _toCfg39.ast;
			const cfg = _toCfg39.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const defaultCase = switchStatement.cases[1];

			(0, _chai.expect)(cfg.isConnected(defaultCase, defaultCase.consequent[0], _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("does not connect the default case with a false branch to any following case statements", () => {
			var _toCfg40 = toCfg(`
			switch (x) {
				default:
					y = null;
				case "A":
					y = 2;
			}
			`);

			const ast = _toCfg40.ast;
			const cfg = _toCfg40.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const defaultCase = switchStatement.cases[0];
			const secondCase = switchStatement.cases[1];

			(0, _chai.expect)(cfg.isConnected(defaultCase, secondCase, _controlFlowGraph.BRANCHES.FALSE)).to.be.false;
		});

		it("connects the case without a consequent to the consequent of a following case statement", () => {
			var _toCfg41 = toCfg(`
			switch (x) {
				case "A":
				default:
					y = null;
			}
			`);

			const ast = _toCfg41.ast;
			const cfg = _toCfg41.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];
			const defaultCase = switchStatement.cases[1];

			(0, _chai.expect)(cfg.isConnected(firstCase, defaultCase.consequent[0], _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});

		it("connects the successor statement of the switch case as true branch for a case without a consequent and any following cases without a consequent", () => {
			var _toCfg42 = toCfg(`
			switch (x) {
				case "A":
				default:
			}
			console.log(y);
			`);

			const ast = _toCfg42.ast;
			const cfg = _toCfg42.cfg;

			// assert

			const switchStatement = ast.program.body[0];
			const firstCase = switchStatement.cases[0];
			const logStatement = ast.program.body[1];

			(0, _chai.expect)(cfg.isConnected(firstCase, null, _controlFlowGraph.BRANCHES.TRUE)).to.be.false;
			(0, _chai.expect)(cfg.isConnected(firstCase, logStatement, _controlFlowGraph.BRANCHES.TRUE)).to.be.true;
		});
	});

	describe("FunctionDeclaration", function () {
		it("connects the function declaration with the successor statement", function () {
			var _toCfg43 = toCfg(`
			function x (z) {
				console.log(z);
			}
			let y = 10;
			`);

			const ast = _toCfg43.ast;
			const cfg = _toCfg43.cfg;

			// assert

			const functionStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(functionStatement, ast.program.body[1], _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the last statement in the function body with the EOF node", function () {
			var _toCfg44 = toCfg(`
			function x (z) {
				console.log(z);
			}
			let y = 10;
			`);

			const ast = _toCfg44.ast;
			const cfg = _toCfg44.cfg;

			// assert

			const functionStatement = ast.program.body[0];
			(0, _chai.expect)(cfg.isConnected(functionStatement.body.body[0], null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("FunctionExpression", function () {
		it("creates cfg nodes for the body of the function expression", function () {
			// act

			var _toCfg45 = toCfg("array.map(function (x) { return x * 2; })");

			const ast = _toCfg45.ast;
			const cfg = _toCfg45.cfg;

			// assert

			const callExpression = ast.program.body[0].expression;
			const functionExpression = callExpression.arguments[0];

			(0, _chai.expect)(cfg.isConnected(functionExpression.body, functionExpression.body.body[0], _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
			(0, _chai.expect)(cfg.isConnected(functionExpression.body.body[0], null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("ArrowFunctionExpression", function () {
		it("creates a cfg node for the body expression of an arrow function expression", function () {
			// act

			var _toCfg46 = toCfg("array.map(x => x * 2)");

			const ast = _toCfg46.ast;
			const cfg = _toCfg46.cfg;

			// assert

			const callExpression = ast.program.body[0].expression;
			const arrowExpression = callExpression.arguments[0];

			(0, _chai.expect)(cfg.isConnected(arrowExpression.body, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("ReturnStatement", function () {
		it("returns null as successor", function () {
			//

			var _toCfg47 = toCfg(`
			function x() {
				return 10;
				console.log("A");
			}
			console.log("B");
			`);

			const ast = _toCfg47.ast;
			const cfg = _toCfg47.cfg;

			// assert

			const functionDeclaration = ast.program.body[0];
			const returnStatement = functionDeclaration.body.body[0];
			const logStatement = functionDeclaration.body.body[1];

			(0, _chai.expect)(cfg.isConnected(returnStatement, logStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.false;
			(0, _chai.expect)(cfg.isConnected(returnStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("fails if a return statement is used inside of try finally", function () {
			(0, _chai.expect)(() => toCfg(`
			function x() {
				try {
					return 10;
				} finally {
					console.log("A");
				}
			}
			`)).to.throw();
		});
	});

	describe("TryStatement", function () {
		it("connects the try statement with the block", () => {
			// act

			var _toCfg48 = toCfg(`
			try {
				callZ();
			} catch (e) {
				console.log(e);
			} 
			`);

			const ast = _toCfg48.ast;
			const cfg = _toCfg48.cfg;

			// assert

			const tryStatement = ast.program.body[0];

			(0, _chai.expect)(cfg.isConnected(tryStatement, tryStatement.block, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("adds an exception connection from a call expression inside the try block to the exception handler", function () {
			// act

			var _toCfg49 = toCfg(`
			try {
				callZ();
			} catch (e) {
				console.log(e);
			} 
			`);

			const ast = _toCfg49.ast;
			const cfg = _toCfg49.cfg;

			// assert

			const tryStatement = ast.program.body[0];
			const callStatement = tryStatement.block.body[0];
			const catchStatement = tryStatement.handler;

			(0, _chai.expect)(cfg.isConnected(callStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
			(0, _chai.expect)(cfg.isConnected(callStatement, catchStatement, _controlFlowGraph.BRANCHES.EXCEPTION)).to.be.true;
		});

		it("does not add exception connection handler for statements in the catch block", function () {
			// act

			var _toCfg50 = toCfg(`
			try {
				callZ();
			} catch (e) {
				console.log(e);
			} 
			`);

			const ast = _toCfg50.ast;
			const cfg = _toCfg50.cfg;

			// assert

			const tryStatement = ast.program.body[0];
			const catchStatement = tryStatement.handler;
			const logStatement = catchStatement.body.body[0];

			(0, _chai.expect)(cfg.isConnected(logStatement, catchStatement)).to.be.false;
		});

		it("Adds exception connection to statements in a finally clause if this is part of another try catch statement", function () {
			// act

			var _toCfg51 = toCfg(`
			try {
				try {
					callZ();
				} finally {
					console.log(e);
				}
			} catch (y) {
				console.log(x);
			}
			`);

			const ast = _toCfg51.ast;
			const cfg = _toCfg51.cfg;

			// assert

			const outerTryStatement = ast.program.body[0];
			const outerCatchStatement = outerTryStatement.handler;
			const innerTryStatement = outerTryStatement.block.body[0];
			const innerFinallyStatement = innerTryStatement.finalizer;
			const innerLogStatement = innerFinallyStatement.body[0];

			(0, _chai.expect)(cfg.isConnected(innerLogStatement, outerCatchStatement, _controlFlowGraph.BRANCHES.EXCEPTION)).to.be.true;
		});
	});

	describe("ThrowStatement", function () {
		it("connects the throw statement with the exit node", function () {
			// act

			var _toCfg52 = toCfg(`
			if (!x) {
			    throw "Ohoh";
			}
			console.log(x);
			`);

			const ast = _toCfg52.ast;
			const cfg = _toCfg52.cfg;

			// assert

			const ifStatement = ast.program.body[0];
			const throwStatement = ifStatement.consequent.body[0];

			(0, _chai.expect)(cfg.isConnected(throwStatement, null, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("connects the throw statement with the enclosing catch clause", function () {
			// act

			var _toCfg53 = toCfg(`
			try {
			    throw "Ohoh";
			} catch (e) {
				console.log(x);
			}
			`);

			const ast = _toCfg53.ast;
			const cfg = _toCfg53.cfg;

			// assert

			const tryStatement = ast.program.body[0];
			const throwStatement = tryStatement.block.body[0];
			const catchClause = tryStatement.handler;

			(0, _chai.expect)(cfg.isConnected(throwStatement, catchClause, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});
	});

	describe("CatchClause", function () {
		it("connects the catch clause with it's body", function () {
			// act

			var _toCfg54 = toCfg(`
			try {
				callZ();
			} catch (e) {
				console.log(e);
			} 
			`);

			const ast = _toCfg54.ast;
			const cfg = _toCfg54.cfg;

			// assert

			const tryStatement = ast.program.body[0];
			const catchStatement = tryStatement.handler;

			(0, _chai.expect)(cfg.isConnected(catchStatement, catchStatement.body, _controlFlowGraph.BRANCHES.UNCONDITIONAL)).to.be.true;
		});

		it("Adds exception connection to statements in a catch clause if this is part of another try catch statement", function () {
			// act

			var _toCfg55 = toCfg(`
			try {
				try {
					callZ();
				} catch (e) {
					console.log(e);
				}
			} catch (y) {
				console.log(x);
			}
			`);

			const ast = _toCfg55.ast;
			const cfg = _toCfg55.cfg;

			// assert

			const outerTryStatement = ast.program.body[0];
			const outerCatchStatement = outerTryStatement.handler;
			const innerTryStatement = outerTryStatement.block.body[0];
			const innerCatchStatement = innerTryStatement.handler;
			const innerLogStatement = innerCatchStatement.body.body[0];

			(0, _chai.expect)(cfg.isConnected(innerLogStatement, outerCatchStatement, _controlFlowGraph.BRANCHES.EXCEPTION)).to.be.true;
		});
	});
});

function toCfg(code) {
	const ast = (0, _babylon.parse)(code);

	const builder = new _cfgBuilder2.default(ast);
	(0, _babelTraverse2.default)(ast, (0, _util.createTraverseVisitorWrapper)(builder));

	return { cfg: ast.cfg, ast: ast };
}
//# sourceMappingURL=cfg-builder.spec.js.map
