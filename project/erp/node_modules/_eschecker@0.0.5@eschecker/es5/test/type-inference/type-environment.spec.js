"use strict";

var _chai = require("chai");

var _immutable = require("immutable");

var _immutable2 = _interopRequireDefault(_immutable);

var _symbol = require("../../lib/semantic-model/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _index = require("../../lib/semantic-model/types/index");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _typeEnvironment2 = _interopRequireDefault(_typeEnvironment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("TypeEnvironment", function () {
	let environment;

	beforeEach(function () {
		environment = new _typeEnvironment2.default();
	});

	it("creates an empty type environment by default", function () {
		// assert
		(0, _chai.expect)(environment.isEmpty).to.be.true;
	});

	describe("setType", function () {

		it("returns a new type environment containing the new mapping for the passed in symbol to the given type", function () {
			// arrange
			const symbol = new _symbol2.default("a", _symbol.SymbolFlags.BlockScopedVariable);
			const type = new _index.Type("number");

			// act
			let newEnvironment = environment.setType(symbol, type);

			// assert
			(0, _chai.expect)(newEnvironment).not.to.equal(environment);
			(0, _chai.expect)(newEnvironment.isEmpty).to.be.false;
			(0, _chai.expect)(newEnvironment.hasType(symbol)).to.be.true;
		});

		it("does not add the type mapping to the existing type environment (it is immutable)", function () {
			// arrange
			const symbol = new _symbol2.default("a", _symbol.SymbolFlags.BlockScopedVariable);
			const type = new _index.Type("number");

			// act
			environment.setType(symbol, type);

			// assert
			(0, _chai.expect)(environment.hasType(symbol)).to.be.false;
		});

		it("throws if the symbol is absent", function () {
			// arrange
			const type = new _index.Type("number");

			// act, assert
			(0, _chai.expect)(() => environment.setType(null, type)).to.throw("A symbol needs to be specified");
		});

		it("throws if the type is absent", function () {
			// arrange
			const symbol = new _symbol2.default("a", _symbol.SymbolFlags.BlockScopedVariable);

			// act, assert
			(0, _chai.expect)(() => environment.setType(symbol, null)).to.throw("A type needs to be specified");
		});
	});

	describe("getType", function () {
		it("returns the type for a given symbol if the environment contains a mapping for the passed in symbol", function () {
			// arrange
			const symbol = new _symbol2.default("a", _symbol.SymbolFlags.BlockScopedVariable);
			const type = new _index.Type("number");

			environment = environment.setType(symbol, type);

			// act, assert
			(0, _chai.expect)(environment.getType(symbol)).to.equal(type);
		});

		it("returns undefined if the type environment does not contain a mapping for the given symbol", function () {
			// arrange
			const symbol = new _symbol2.default("a", _symbol.SymbolFlags.BlockScopedVariable);

			// act, assert
			(0, _chai.expect)(environment.getType(symbol)).to.be.undefined;
		});
	});

	describe("hasType", function () {
		it("returns true if the type environment contains a definition for the given symbol", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const typeEnvironment = new _typeEnvironment2.default().setType(name, _index.StringType.create());

			// act, assert
			(0, _chai.expect)(typeEnvironment.hasType(name)).to.be.true;
		});

		it("returns false if the type environment does not contain a definition for the given symbol", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);
			const typeEnvironment = new _typeEnvironment2.default().setType(name, _index.StringType.create());

			// act, assert
			(0, _chai.expect)(typeEnvironment.hasType(age)).to.be.false;
		});
	});

	describe("substitute", function () {
		it("returns a new type environment where the given type has been replaced", function () {
			// arrange
			const t = _index.NullType.create();
			const newT = _index.NumberType.create();

			const x = new _symbol2.default("x");
			const typeEnvironment = new _typeEnvironment2.default(new _immutable2.default.Map([[x, t]]));

			// act
			const substituted = typeEnvironment.substitute(t, newT);

			// assert
			(0, _chai.expect)(substituted).not.to.equal(typeEnvironment);
			(0, _chai.expect)(substituted.getType(x)).to.equal(newT);
		});

		it("returns a new type environment where the given type and all types that have used the given type as type parameter are replaced", function () {
			// arrange
			const t = _index.StringType.create();
			const newT = _index.NumberType.create();
			const maybe = _index.MaybeType.of(t);

			const x = new _symbol2.default("x");
			const y = new _symbol2.default("y");
			const typeEnvironment = new _typeEnvironment2.default(new _immutable2.default.Map([[x, t], [y, maybe]]));

			// act
			const substituted = typeEnvironment.substitute(t, newT);

			// assert
			(0, _chai.expect)(substituted.getType(y)).not.to.equal(maybe);
			(0, _chai.expect)(substituted.getType(y).of).to.equal(newT);
		});

		it("returns this if the old and new type are the same instance", function () {
			// arrange
			const t = _index.TypeVariable.create();

			const x = new _symbol2.default("x");
			const y = new _symbol2.default("y");

			const typeEnvironment = new _typeEnvironment2.default().setType(x, t).setType(y, t);

			// act, assert
			(0, _chai.expect)(typeEnvironment.substitute(t, t)).to.be.equals(typeEnvironment);
		});

		it("returns this if no type has been substituted", function () {
			// arrange
			const t = _index.TypeVariable.create();
			const t2 = _index.TypeVariable.create();

			const x = new _symbol2.default("x");
			const y = new _symbol2.default("y");

			const typeEnvironment = new _typeEnvironment2.default().setType(x, t).setType(y, t);

			// act, assert
			(0, _chai.expect)(typeEnvironment.substitute(t2, t)).to.be.equal(typeEnvironment);
		});
	});

	describe("difference", function () {
		it("returns a type environment containing newly added definitions", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const before = new _typeEnvironment2.default().setType(name, _index.StringType.create());
			const after = before.setType(age, _index.NumberType.create());

			// act
			const difference = after.difference(before);

			// assert
			(0, _chai.expect)(difference.hasType(name)).to.be.false;
			(0, _chai.expect)(difference.getType(age)).to.be.instanceOf(_index.NumberType);
		});

		it("returns a type environment containing the changed definitions", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const before = new _typeEnvironment2.default().setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());
			const after = before.setType(age, _index.MaybeType.of(_index.NumberType.create()));

			// act
			const difference = after.difference(before);

			// assert
			(0, _chai.expect)(difference.hasType(name)).to.be.false;
			(0, _chai.expect)(difference.getType(age)).to.be.instanceOf(_index.MaybeType);
		});

		it("returns an empty type environment if before and after are equal", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const before = new _typeEnvironment2.default().setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act
			const difference = before.difference(before);

			// assert
			(0, _chai.expect)(difference).to.eql(new _typeEnvironment2.default());
		});

		it("returns this if all mappings are new compared to the type environment before", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const before = new _typeEnvironment2.default();
			const after = before.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act
			const difference = after.difference(before);

			// assert
			(0, _chai.expect)(difference).to.equals(after);
		});
	});

	describe("add", function () {
		it("returns a new type environment that contains the mapping of this type environment and the passed in", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create());
			const env2 = environment.setType(age, _index.NumberType.create());

			// act
			const added = env1.add(env2);

			// assert
			(0, _chai.expect)(added.getType(name)).to.be.instanceOf(_index.StringType);
			(0, _chai.expect)(added.getType(age)).to.be.instanceOf(_index.NumberType);
		});

		it("does not override mappings from the this type environment", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create());
			const env2 = environment.setType(age, _index.NumberType.create()).setType(name, _index.NullType.create());

			// act
			const added = env1.add(env2);

			// assert
			(0, _chai.expect)(added.getType(name)).to.be.instanceOf(_index.StringType);
			(0, _chai.expect)(added.getType(age)).to.be.instanceOf(_index.NumberType);
		});

		it("returns this if no new mappings have been added", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());
			const env2 = environment.setType(age, _index.NumberType.create()).setType(name, _index.StringType.create());

			// act
			const added = env1.add(env2);

			// assert
			(0, _chai.expect)(added).to.equals(env1);
		});
	});

	describe("replaceTypes", function () {
		it("replaces the types for the symbols with the new type", function () {
			// arrange
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(age, _index.TypeVariable.create());
			const env2 = environment.setType(age, _index.NumberType.create());

			// act
			const replaced = env1.replaceTypes(env2);

			// assert
			(0, _chai.expect)(replaced.getType(age)).to.be.instanceOf(_index.NumberType);
		});

		it("does not replace the types of excluded symbols", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.TypeVariable.create()).setType(age, _index.NullType.create());
			const env2 = environment.setType(age, _index.NumberType.create()).setType(name, _index.StringType.create());

			// act
			const replaced = env1.replaceTypes(env2, [age]);

			// assert
			(0, _chai.expect)(replaced.getType(name)).to.be.instanceOf(_index.StringType);
			(0, _chai.expect)(replaced.getType(age)).to.be.instanceOf(_index.NullType);
		});

		it("does not add new members", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.TypeVariable.create());
			const env2 = environment.setType(age, _index.NumberType.create()).setType(name, _index.StringType.create());

			// act
			const replaced = env1.replaceTypes(env2);

			// assert
			(0, _chai.expect)(replaced.getType(age)).not.to.be.defined;
		});
	});

	describe("equals", function () {
		it("returns true if the two type environments contain the same mappings to the same type instances", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const nameT = _index.StringType.create();
			const ageT = _index.NumberType.create();

			const env1 = environment.setType(name, nameT).setType(age, ageT);
			const env2 = environment.setType(name, nameT).setType(age, ageT);

			// act, assert
			(0, _chai.expect)(env1.equals(env2)).to.be.true;
			(0, _chai.expect)(env2.equals(env1)).to.be.true;
		});

		it("returns true if the two type environments contains the same mappings with equal types", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, new _index.StringType()).setType(age, new _index.NumberType());
			const env2 = environment.setType(name, new _index.StringType()).setType(age, new _index.NumberType());

			// act, assert
			(0, _chai.expect)(env1.equals(env2)).to.be.true;
			(0, _chai.expect)(env2.equals(env1)).to.be.true;
		});

		it("returns false if the two type environment contains the same mappings but with different types", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create()).setType(age, _index.NullType.create());
			const env2 = environment.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act, assert
			(0, _chai.expect)(env1.equals(env2)).to.be.false;
			(0, _chai.expect)(env2.equals(env1)).to.be.false;
		});

		it("returns false if the two type environment do not contain the same mappings", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create());
			const env2 = environment.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act, assert
			(0, _chai.expect)(env1.equals(env2)).to.be.false;
			(0, _chai.expect)(env2.equals(env1)).to.be.false;
		});
	});

	describe("hashCode", function () {
		it("returns the same hash code for two type environments containing the same mappings to the same type instances", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const nameT = _index.StringType.create();
			const ageT = _index.NumberType.create();

			const env1 = environment.setType(name, nameT).setType(age, ageT);
			const env2 = environment.setType(name, nameT).setType(age, ageT);

			// act, assert
			(0, _chai.expect)(env1.hashCode()).to.equal(env2.hashCode());
		});

		it("returns different hash codes for two type environment containing the same mappings but with different types", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create()).setType(age, _index.NullType.create());
			const env2 = environment.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act, assert
			(0, _chai.expect)(env1.hashCode()).not.to.equal(env2.hashCode());
		});

		it("returns different hash codes for two type environment that do not contain the same mappings", function () {
			// arrange
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol2.default("age", _symbol.SymbolFlags.Variable);

			const env1 = environment.setType(name, _index.StringType.create());
			const env2 = environment.setType(name, _index.StringType.create()).setType(age, _index.NumberType.create());

			// act, assert
			(0, _chai.expect)(env1.hashCode()).not.to.equal(env2.hashCode());
		});
	});
});
//# sourceMappingURL=type-environment.spec.js.map
