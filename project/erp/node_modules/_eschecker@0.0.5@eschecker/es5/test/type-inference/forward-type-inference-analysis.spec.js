"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _forwardTypeInferenceAnalysis = require("../../lib/type-inference/forward-type-inference-analysis");

var _program = require("../../lib/semantic-model/program");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _symbol = require("../../lib/semantic-model/symbol");

var _types = require("../../lib/semantic-model/types");

var _hindleyMilner = require("../../lib/type-inference/hindley-milner");

var _sourceFile = require("../../lib/semantic-model/source-file");

var _controlFlowGraph = require("../../lib/cfg/control-flow-graph");

var _hindleyMilnerContext = require("../../lib/type-inference/hindley-milner-context");

var _typeInferenceContext = require("../../lib/type-inference/type-inference-context");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("ForwardTypeInferenceAnalysis", function () {
	let analysis, program, hindleyMilner, sandbox;

	beforeEach(function () {
		sandbox = _sinon2.default.sandbox.create();
		program = new _program.Program();
		hindleyMilner = new _hindleyMilner.HindleyMilner();
		analysis = new _forwardTypeInferenceAnalysis.ForwardTypeInferenceAnalysis(program, hindleyMilner);
	});

	afterEach(function () {
		sandbox.restore();
	});

	describe("analyseSourceFile", function () {
		it("analyse all ast nodes in the source file", function () {
			// arrange
			const programNode = t.program([t.variableDeclaration("let", [t.variableDeclarator(t.identifier("x"))]), t.expressionStatement(t.unaryExpression("++", t.identifier("x")))]);
			const sourceFile = new _sourceFile.SourceFile("./test.js", "let x", null);
			sourceFile.ast = { program: programNode };

			const cfg = new _controlFlowGraph.ControlFlowGraph();
			cfg.connectIfNotFound(programNode.body[0], _controlFlowGraph.BRANCHES.UNCONDITIONAL, programNode.body[1]);
			cfg.connectIfNotFound(programNode.body[1], _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);
			sourceFile.ast.cfg = cfg;

			sandbox.stub(hindleyMilner, "infer");

			// act
			analysis.analyseSourceFile(sourceFile);

			// assert
			_sinon2.default.assert.calledWith(hindleyMilner.infer, programNode.body[0]);
			_sinon2.default.assert.calledWith(hindleyMilner.infer, programNode.body[1]);
		});
	});

	describe("analyse", function () {
		it("analyses the given node and it's successor nodes", function () {
			// arrange
			const variableDeclaration = t.variableDeclaration("let", [t.variableDeclarator(t.identifier("x"))]);
			const updateExpression = t.expressionStatement(t.unaryExpression("++", t.identifier("x")));

			const cfg = new _controlFlowGraph.ControlFlowGraph();
			cfg.connectIfNotFound(variableDeclaration, _controlFlowGraph.BRANCHES.UNCONDITIONAL, updateExpression);
			cfg.connectIfNotFound(updateExpression, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);

			sandbox.stub(hindleyMilner, "infer");
			sandbox.stub(program, "getCfg").returns(cfg);

			// act
			analysis.analyse(variableDeclaration);

			// assert
			_sinon2.default.assert.calledWith(hindleyMilner.infer, variableDeclaration);
			_sinon2.default.assert.calledWith(hindleyMilner.infer, updateExpression);
		});
	});

	describe("joinTypeEnvironments", function () {
		it("merges the definitions into a new type environment containing the definitions of both environments", function () {
			// arrange
			const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Variable);

			const env1 = new _typeEnvironment.TypeEnvironment().setType(name, _types.VoidType.create());
			const env2 = new _typeEnvironment.TypeEnvironment().setType(age, _types.NullType.create());

			sandbox.stub(hindleyMilner, "mergeWithTypeEnvironments");

			const node = {};

			// act
			analysis.joinTypeEnvironments(env1, [env2], node);

			// assert
			_sinon2.default.assert.calledWith(hindleyMilner.mergeWithTypeEnvironments, [env2], node, _sinon2.default.match.has("typeEnvironment", env1));
		});
	});

	describe("createTypeInferenceContext", function () {
		it("creates a new type inference context with the given type environment", function () {
			// arrange
			const typeEnvironment = new _typeEnvironment.TypeEnvironment();

			// act
			const context = analysis.createTypeInferenceContext(typeEnvironment);

			// assert
			(0, _chai.expect)(context).to.be.instanceOf(_typeInferenceContext.TypeInferenceContext);
			(0, _chai.expect)(context.typeEnvironment).to.equal(typeEnvironment);
		});
	});

	describe("createHindleyMilnerContext", function () {
		it("creates a new context that is based on the given type environment", function () {
			// arrange
			const typeEnvironment = new _typeEnvironment.TypeEnvironment();

			// act
			const context = analysis.createHindleyMilnerContext(typeEnvironment);

			// assert
			(0, _chai.expect)(context).to.be.instanceOf(_hindleyMilnerContext.HindleyMilnerContext);
			(0, _chai.expect)(context.typeEnvironment).to.equal(typeEnvironment);
		});

		it("creates a new context that is based on the given type inference context", function () {
			// arrange
			const typeEnvironment = new _typeEnvironment.TypeEnvironment();
			const typeInferenceContext = new _typeInferenceContext.TypeInferenceContext(program, typeEnvironment);

			// act
			const context = analysis.createHindleyMilnerContext(typeInferenceContext);

			// assert
			(0, _chai.expect)(context).to.be.instanceOf(_hindleyMilnerContext.HindleyMilnerContext);
			(0, _chai.expect)(context.typeEnvironment).to.equal(typeEnvironment);
		});
	});
});
//# sourceMappingURL=forward-type-inference-analysis.spec.js.map
