"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.UpdateExpressionRefinementRule = undefined;

var _typeInferenceError = require("../type-inference-error");

var _types = require("../../semantic-model/types");

const numberT = _types.NumberType.create();
const maybeNumber = _types.MaybeType.of(numberT);

/**
 * Refinement rule for update expressions like ++, --
 * @implements {RefinementRule}
 */
class UpdateExpressionRefinementRule {
	canRefine(node) {
		return node.type === "UpdateExpression";
	}

	refine(node, context) {
		if (node.operator !== "++" && node.operator !== "--") {
			throw new _typeInferenceError.TypeInferenceError(`Unsupported update operator ${ node.operator }.`, node);
		}

		const argumentType = context.infer(node.argument);
		context.unify(maybeNumber, argumentType, node.argument);
		return numberT;
	}
}

exports.UpdateExpressionRefinementRule = UpdateExpressionRefinementRule;
exports.default = UpdateExpressionRefinementRule;
//# sourceMappingURL=update-expression-refinement-rule.js.map
