"use strict";

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _workListDataFlowAnalysis = require("../../lib/data-flow-analysis/work-list-data-flow-analysis");

var _controlFlowGraph = require("../../lib/cfg/control-flow-graph");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("WorkListDataFlowAnalysis", function () {
	let sandbox, analysis, cfg;

	beforeEach(function () {
		sandbox = _sinon2.default.sandbox.create();
		cfg = new _controlFlowGraph.ControlFlowGraph();

		analysis = new _workListDataFlowAnalysis.WorkListDataFlowAnalysis();
	});

	describe("analyse", function () {
		it("calls the transfer function for each node", function () {
			// arrange
			const functionDeclaration = "function () {";
			const variableDeclarator = "let x = 10;";
			const variableDeclarator2 = "let y = 19";
			const returnStatement = "return x + y;";

			cfg.connectIfNotFound(functionDeclaration, _controlFlowGraph.BRANCHES.UNCONDITIONAL, variableDeclarator);
			cfg.connectIfNotFound(variableDeclarator, _controlFlowGraph.BRANCHES.UNCONDITIONAL, variableDeclarator2);
			cfg.connectIfNotFound(variableDeclarator2, _controlFlowGraph.BRANCHES.UNCONDITIONAL, returnStatement);
			cfg.connectIfNotFound(returnStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);

			sandbox.stub(analysis, "createEmptyLattice").returns({});
			sandbox.stub(analysis, "transfer").returns({});
			sandbox.stub(analysis, "areStatesEqual").returns(true);

			// act
			analysis.analyse(cfg);

			// assert
			_sinon2.default.assert.calledWith(analysis.transfer, functionDeclaration);
			_sinon2.default.assert.calledWith(analysis.transfer, variableDeclarator);
			_sinon2.default.assert.calledWith(analysis.transfer, variableDeclarator2);
			_sinon2.default.assert.calledWith(analysis.transfer, returnStatement);
			_sinon2.default.assert.calledWith(analysis.transfer, null);

			_sinon2.default.assert.callCount(analysis.transfer, 5);
		});

		it("process only the nodes that have a path from the passed in node to the exit node", function () {
			// arrange
			const functionDeclaration = "function () {";
			const variableDeclarator = "let x = 10;";
			const variableDeclarator2 = "let y = 19";
			const returnStatement = "return x + y;";

			cfg.connectIfNotFound(functionDeclaration, _controlFlowGraph.BRANCHES.UNCONDITIONAL, variableDeclarator);
			cfg.connectIfNotFound(variableDeclarator, _controlFlowGraph.BRANCHES.UNCONDITIONAL, variableDeclarator2);
			cfg.connectIfNotFound(variableDeclarator2, _controlFlowGraph.BRANCHES.UNCONDITIONAL, returnStatement);
			cfg.connectIfNotFound(returnStatement, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);

			sandbox.stub(analysis, "createEmptyLattice").returns({});
			sandbox.stub(analysis, "transfer").returns({});
			sandbox.stub(analysis, "areStatesEqual").returns(true);

			// act
			analysis.analyse(cfg, variableDeclarator2);

			// assert
			_sinon2.default.assert.calledWith(analysis.transfer, variableDeclarator2);
			_sinon2.default.assert.calledWith(analysis.transfer, returnStatement);
			_sinon2.default.assert.calledWith(analysis.transfer, null);

			_sinon2.default.assert.callCount(analysis.transfer, 3);
		});

		it("reschedules the successor nodes if the in and out lattice of a node are not equal", function () {
			// arrange
			const declaration = cfg.createNode("let x = 1");
			const whileStatement = cfg.createNode("while (x)");
			const whileBody = cfg.createNode("--x");
			const whileSuccessor = cfg.createNode("console.log(x)");
			const exitNode = cfg.createNode(null);

			cfg.connectIfNotFound(declaration, _controlFlowGraph.BRANCHES.UNCONDITIONAL, whileStatement);
			cfg.connectIfNotFound(whileStatement, _controlFlowGraph.BRANCHES.TRUE, whileBody);
			cfg.connectIfNotFound(whileBody, _controlFlowGraph.BRANCHES.UNCONDITIONAL, whileStatement);
			cfg.connectIfNotFound(whileStatement, _controlFlowGraph.BRANCHES.FALSE, whileSuccessor);
			cfg.connectIfNotFound(whileSuccessor, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);

			sandbox.stub(analysis, "createEmptyLattice").returns("empty");

			const whileResult1 = "x = 1";

			sandbox.stub(analysis, "transfer").withArgs(whileBody.value, "empty").returns(whileResult1);
			analysis.transfer.returnsArg(1);

			sandbox.stub(analysis, "areStatesEqual").withArgs("empty", whileResult1).returns(false);
			analysis.areStatesEqual.returns(true);

			sandbox.stub(analysis, "joinBranches").withArgs("empty", ["x = 1"]).returns("x = 1");
			analysis.joinBranches.returnsArg(0);

			// act
			analysis.analyse(cfg);

			// assert
			_sinon2.default.assert.calledWith(analysis.transfer, declaration.value, "empty");
			_sinon2.default.assert.calledWith(analysis.transfer, whileStatement.value, "empty");
			_sinon2.default.assert.calledWith(analysis.transfer, whileStatement.value, "x = 1");
			_sinon2.default.assert.calledWith(analysis.transfer, whileBody.value, "empty");
			_sinon2.default.assert.calledWith(analysis.transfer, whileBody.value, "x = 1");
			_sinon2.default.assert.calledWith(analysis.transfer, whileSuccessor.value, "empty");
			_sinon2.default.assert.calledWith(analysis.transfer, whileSuccessor.value, "x = 1");
			_sinon2.default.assert.calledWith(analysis.transfer, exitNode.value, "empty");
			_sinon2.default.assert.calledWith(analysis.transfer, exitNode.value, "x = 1");
		});
	});
});
//# sourceMappingURL=work-List-data-flow-analysis.spec.js.map
