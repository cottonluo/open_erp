"use strict";

var _chai = require("chai");

var _types = require("../../../lib/semantic-model/types");

describe("ParametrizedType", function () {

	describe("prettyName", function () {
		it("contains the type parameters", function () {
			// arrange
			const t1 = new TestParametrizedType("Function", [new _types.Type("number"), new _types.Type("string")]);

			// act, assert
			(0, _chai.expect)(t1.prettyName).to.equal("Function<number, string>");
		});
	});

	describe("fresh", function () {
		it("returns a new instance with the same name and type parameters", function () {
			// arrange
			const t = new TestParametrizedType("x", [new _types.Type("number")]);

			// act
			const fresh = t.fresh();

			// assert
			(0, _chai.expect)(fresh).not.to.equal(t);
			(0, _chai.expect)(fresh.name).to.equal(t.name);
			(0, _chai.expect)(fresh.typeParameters).to.deep.equal(t.typeParameters);
		});

		it("returns a new instance that has not the same id as the original one", function () {
			// arrange
			const t = new TestParametrizedType("x", [new _types.Type("number")], 10);

			// act
			const fresh = t.fresh();

			// assert
			(0, _chai.expect)(fresh.id).not.to.equal(t.id);
		});
	});

	describe("containsType", function () {
		it("returns true if the type occurs in a type parameter of the other type", function () {
			// arrange
			const t1 = new _types.Type("number");
			const t2 = new TestParametrizedType("number", [t1]);

			// act, assert
			(0, _chai.expect)(t1.occursIn(t2)).to.be.true;
		});

		it("returns true if the type occurs in a type parameter of a type parameter", function () {
			// arrange
			const t1 = new _types.Type("number");
			const t2 = new TestParametrizedType("maybe", [t1]);
			const t3 = new TestParametrizedType("array", [t2]);

			// act, assert
			(0, _chai.expect)(t1.occursIn(t3)).to.be.true;
		});
	});

	describe("isSameType", function () {
		it("returns true if both types have the same constructor but different type parameters", function () {
			// arrange
			const numberType = new _types.Type("number");
			const stringType = new _types.Type("string");
			const first = new TestParametrizedType("array", [numberType]);
			const second = new TestParametrizedType("array", [stringType]);

			// act, assert
			(0, _chai.expect)(first.isSameType(second)).to.be.true;
		});

		it("returns false if the types have not the same constructors", function () {
			// arrange
			const first = new _types.Type("number");
			const second = new TestParametrizedType("optional", [new _types.Type("number")]);

			// act, assert
			(0, _chai.expect)(first.isSameType(second)).to.be.false;
		});
	});

	describe("equals", function () {
		it("returns true if both types are from the same types and have the same type parameters", function () {
			// arrange
			const numberType = new _types.Type("number");
			const first = new TestParametrizedType("optional", [numberType]);
			const second = new TestParametrizedType("optional", [numberType]);

			// act, assert
			(0, _chai.expect)(first.equals(second)).to.be.true;
			(0, _chai.expect)(second.equals(first)).to.be.true;
		});

		it("returns false if the types are not from the same kind", function () {
			// arrange
			const first = new _types.Type("number");
			const second = _types.MaybeType.of(new _types.Type("number"));

			// act, assert
			(0, _chai.expect)(first.equals(second)).to.be.false;
			(0, _chai.expect)(second.equals(first)).to.be.false;
		});

		it("returns false if the types have not the same number of type parameters", function () {
			// arrange
			const first = new TestParametrizedType("number");
			const second = new TestParametrizedType("array", [new _types.Type("number")]);

			// act, assert
			(0, _chai.expect)(first.equals(second)).to.be.false;
			(0, _chai.expect)(second.equals(first)).to.be.false;
		});

		it("returns false if the parameter types are not equal", function () {
			// arrange
			const first = new TestParametrizedType("array", [_types.MaybeType.of(new _types.Type("number"))]);
			const second = new TestParametrizedType("array", [new _types.Type("number")]);

			// act, assert
			(0, _chai.expect)(first.equals(second)).to.be.false;
			(0, _chai.expect)(second.equals(first)).to.be.false;
		});
	});

	describe("substitute", function () {
		it("returns the newType if this is the same as the new type", function () {
			// arrange
			const t = new TestParametrizedType("array", [new _types.Type("number")]);
			const newT = new TestParametrizedType("array", [new _types.Type("maybe")]);

			// act, assert
			(0, _chai.expect)(t.substitute(t, newT)).to.equal(newT);
		});

		it("returns this if no parameter has been replaced", function () {
			// arrange
			const t = new TestParametrizedType("array", [new _types.Type("number")]);

			// act, assert
			(0, _chai.expect)(t.substitute(new _types.Type("old"), new _types.Type("new"))).to.equal(t);
		});

		it("returns a new type where all occurrences of the old type in the type parameters are replaced", function () {
			// arrange
			const oldType = new _types.Type("number");
			const t = new TestParametrizedType("array", [oldType]);

			const newType = _types.MaybeType.of(new _types.Type("number"));

			// act
			const substituted = t.substitute(oldType, newType);

			// assert
			(0, _chai.expect)(substituted.typeParameters[0]).to.equal(newType);
		});
	});

	describe("isSubType", function () {
		it("returns true if the type parameters of t are all subtypes of this type", function () {
			// arrange
			const t = new TestParametrizedType("array", [_types.MaybeType.of(_types.NumberType.create())]);
			const tSub = new TestParametrizedType("array", [_types.NumberType.create()]);

			// act, assert
			(0, _chai.expect)(t.isSubType(tSub)).to.be.true;
		});

		it("returns false if any type parameter of t is not a subtype of this type", function () {
			// arrange
			const t = new TestParametrizedType("array", [_types.MaybeType.of(_types.NumberType.create()), _types.StringType.create()]);
			const tNotSub = new TestParametrizedType("array", [_types.NullType.create(), _types.NumberType.create()]);

			// act, assert
			(0, _chai.expect)(t.isSubType(tNotSub)).to.be.false;
		});

		it("returns false if t is of a different type", function () {
			// arrange
			const t = new TestParametrizedType("array", [_types.NumberType.create()]);
			const tDifferent = _types.MaybeType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(t.isSubType(tDifferent)).to.be.false;
		});
	});
});

class TestParametrizedType extends _types.ParametrizedType {
	constructor(name) {
		let typeParameters = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
		let id = arguments.length <= 2 || arguments[2] === undefined ? undefined : arguments[2];

		super(name, id);
		this._typeParameters = typeParameters;
	}

	get typeParameters() {
		return this._typeParameters;
	}

	withTypeParameters(value, id) {
		return new TestParametrizedType(this.name, value, id);
	}
}
//# sourceMappingURL=parametrized-type.spec.js.map
