"use strict";

var _chai = require("chai");

var _types = require("../../../lib/semantic-model/types");

describe("FunctionType", function () {

	describe("typeParameters", function () {
		it("returns an array containing the this and return type for a function without parameters", function () {
			// arrange
			const thisType = new _types.Type("this");
			const returnType = _types.VoidType.create();
			const functionType = new _types.FunctionType(thisType, [], returnType, {});

			// act, assert
			(0, _chai.expect)(functionType.typeParameters).to.deep.equal([thisType, returnType]);
		});

		it("returns an array containing the this type, the types of all parameters and the return type for a function with parameters", function () {
			// arrange
			const thisType = new _types.Type("this");
			const param1 = new _types.Type("number");
			const param2 = new _types.Type("string");
			const returnType = _types.VoidType.create();
			const functionType = new _types.FunctionType(thisType, [param1, param2], returnType, {});

			// act, assert
			(0, _chai.expect)(functionType.typeParameters).to.deep.equal([thisType, returnType, param1, param2]);
		});
	});

	describe("withTypeParameters", function () {
		it("returns a new instance with the specified id", function () {
			// arrange
			const functionType = new _types.FunctionType(new _types.Type("oldThis"), [new _types.Type("number")], new _types.Type("OldReturn"), {});

			// act
			const newFunction = functionType.withTypeParameters([new _types.Type("this"), _types.VoidType.create(), new _types.Type("number"), new _types.Type("string")], functionType.id);

			// assert
			(0, _chai.expect)(newFunction).not.to.equal(functionType);
			(0, _chai.expect)(newFunction.id).to.equal(functionType.id);
		});

		it("returns a new instance with the given this, param and return types", function () {
			// arrange
			const thisType = new _types.Type("this");
			const param1 = new _types.Type("number");
			const param2 = new _types.Type("string");
			const returnType = _types.VoidType.create();
			const functionType = new _types.FunctionType(new _types.Type("oldThis"), [param1], new _types.Type("OldReturn"), {});

			// act
			const newFunction = functionType.withTypeParameters([thisType, returnType, param1, param2]);

			// assert
			(0, _chai.expect)(newFunction.thisType).to.equal(thisType);
			(0, _chai.expect)(newFunction.params).to.deep.equal([param1, param2]);
			(0, _chai.expect)(newFunction.returnType).to.equal(returnType);
		});
	});

	describe("prettyName", function () {
		it("returns a string representation of the form thisType.(parameterTypes) -> returnType", function () {
			// arrange
			const functionType = new _types.FunctionType(new _types.Type("this"), [new _types.Type("number"), new _types.Type("string")], new _types.Type("number"), {});

			// act, assert
			(0, _chai.expect)(functionType.prettyName).to.equals("this.(number, string) -> number");
		});
	});
});
//# sourceMappingURL=function-type.spec.js.map
