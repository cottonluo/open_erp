"use strict";

var _process = require("process");

var _process2 = _interopRequireDefault(_process);

var _commander = require("commander");

var _commander2 = _interopRequireDefault(_commander);

var _pkginfo = require("pkginfo");

var _pkginfo2 = _interopRequireDefault(_pkginfo);

var _chalk = require("chalk");

var _chalk2 = _interopRequireDefault(_chalk);

var _configuration = require("./configuration");

var _configuration2 = _interopRequireDefault(_configuration);

var _context = require("./context");

var _context2 = _interopRequireDefault(_context);

var _infer = require("./infer");

var _program = require("./semantic-model/program");

var _typeEnvironment = require("./type-inference/type-environment");

var _dot = require("./cfg/dot");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console */

(0, _pkginfo2.default)(module);

_commander2.default.version(module.exports.version).option("-f, --file <path>", "the entry file for the application to validate.").option("-c, --cfg [path]", "outputs the generated control flow graph to the given path").parse(_process2.default.argv);

if (!_commander2.default.file) {
	console.error(_chalk2.default.red("no file to validate given"));
	_commander2.default.help();
}

console.info(_chalk2.default.green("Initial memory usage", _process2.default.memoryUsage().rss / 1024 / 1024));

const configuration = new _configuration2.default();
const context = new _context2.default(configuration);
const program = new _program.Program();

try {
	console.log(_chalk2.default.green(_commander2.default.file));

	const content = context.moduleResolution.readFile(_commander2.default.file);
	const canoncialName = context.moduleResolution.canoncialName(_commander2.default.file);

	const sourceFile = program.createSourceFile(canoncialName, content);
	const typeEnvironments = (0, _infer.infer)(sourceFile, program);

	if (_commander2.default.cfg) {
		const options = _commander2.default.cfg === true ? {} : { path: _commander2.default.cfg };
		(0, _dot.plotControlFlowGraph)(sourceFile.ast.cfg, options);
	}

	const typeEnvironment = typeEnvironments.get(null) || _typeEnvironment.TypeEnvironment.EMPTY;

	console.log("Final type environment in exit node:");
	typeEnvironment.dump(_process2.default.stdout);

	console.log(_chalk2.default.green("Final memory usage:", _process2.default.memoryUsage().rss / 1024 / 1024));
	console.log(_chalk2.default.green("Success"));
} catch (error) {
	let message;
	if (error.node && error.node.loc) {
		const sourceFile = program.getSourceFile(error.node.loc.filename);
		message = _chalk2.default.red("Type inference failed for node ") + "\n" + sourceFile.codeFrame(error.node);
	} else {
		message = _chalk2.default.red("An error occurred during the program analysis");
	}

	console.log(message);
	console.log(error.stack);
}
//# sourceMappingURL=cli.js.map
