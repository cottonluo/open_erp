\section{Introduction}\label{sec:introduction}
The role of JavaScript dramatically changed over the last years. From an unpopular language used to add dynamic effects to web pages to a widely used language with a strong and growing community. It emerged from a browser only language to a general purpose language used to write web-,  desktop-, mobile-, and server-applications. This shift is reflected in an increasing complexity and number of JavaScript projects. To tackle the higher complexity, a better tooling support is needed for effective development and refactoring.  

JavaScript does not provide any static analysis for proving the soundness of a program. Type and nullability checking is only performed at runtime. Performing refactorings or adding new functionality is therefore a risky task, as the programer has a very limited tooling for testing if changes have been applied correctly. Static type checking allows to detect common errors like accessing non-declared variables, missing arguments, arguments in incorrect order or invoking a non function type, without the need to execute the program. It therefore is a valuable tool for providing a fast statement about the soundness of a program.

JavaScript is a dynamically typed language and therefore requires type inference for type checking. Type inference for JavaScript is a non-trivial task because of the very dynamic nature of JavaScript~\cite{JensenMollerThiemann2009}. JavaScript has several features that makes static program analysis difficult. An explanation of the language features adding complexity to static analysis follows.

\begin{description}
	\item[Dynamic Objects] A JavaScript object is a mapping from a string key to a value. Adding new properties or removing existing once can be performed dynamically. A property name can either be a static or computed value. The later is used for dynamic object creation or modification, similar to code using reflection in statically typed languages. 
	
	\item[Closures] Functions have access to variables from their enclosing scope. Invoking a function requires that the function is evaluated in its declaration scope. Therefore the analysis needs to be context-sensitive.

	\item[Side effects] Functions in JavaScript are not pure and therefore invoking a function can have side effects to arguments passed to the function or variables from the outer scope of the function declaration. These side effects can also affect the type of the involved variables, e.g. if the function assigns a value of a different type to an outer scope variable or adds a new property to a parameter. A precise analysis needs to reflect these side effects in the caller's context.
	
	\item[This Binding] The object referenced by \textit{this} depends on the  function kind and its usage. Arrow functions capture the \textit{this} of the enclosing context. The \textit{this} inside of a function declarations or expressions depends on the usage. The \textit{this} can explicitly be specified if the function is invoked using \textit{call} or \textit{apply}. Otherwise the binding of \textit{this} is implicitly defined. If the function is called as a method of an object, then \textit{this} is equal to the object, to which the method belongs. If the function is not a member of an object, then \textit{this} references the global object. 

	\item[Host-Environment] The preliminary host-environment of JavaScript applications is still the browser. However, it is also used for standalone applications or to add scripting functionality to other applications. In this case, NodeJS, Rhino or another JavaScript engine is used as host-environment. Each environment exposes different native objects and methods at runtime, e.g. the browser exposes the DOM-API. A type checker needs to specifically model these objects and methods as their JavaScript code is not existent.
\end{description}

Implementing a sound type checker for JavaScript risks to be over-restrictive and only allows a very limited subset of JavaScript programs or reports a large amount of false positives. An unsound type system has the disadvantage that it does not detect all errors but allows type checking of a far more complete set of JavaScript programs and therefore has a better chance to be applied in actual practice. 

This work defines a sound algorithm that is capable of inferring the types and perform type checking for a majority of the written code. The precision degrades for very dynamic code, e.g. code that uses dynamic object creation or manipulation. The algorithm is unsound for these cases as the inferred types might be imprecise. It is expected that these features are mainly used in frameworks or libraries. This work suggests to substitute type inference for these edge cases by using type annotations. The presented analysis is limited to JavaScript code written in strict mode. Features prohibited in strict mode are not supported by the analysis.


The first section compares this work with existing tools used to verify or analyze JavaScript programs. \Cref{sec:strict-mode} explains the benefits of restricting the analysis to strict mode and why it is believed that the code written in strict mode will be growing in the near future. The basics of the algorithm are explained in \cref{sec:algorithm}, the results from the evaluation are shown in the preceding section and is followed by the conclusion.
