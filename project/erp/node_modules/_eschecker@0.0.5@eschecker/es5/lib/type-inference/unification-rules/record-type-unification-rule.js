"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.RecordTypeUnificationRule = undefined;

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _immutable = require("immutable");

var _immutable2 = _interopRequireDefault(_immutable);

var _types = require("../../semantic-model/types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Rule for unification of two record types. The unification of two record types is the intersection of the properties with unified types.
 * @implements {BaseTypeUnificationRule}
 */
class RecordTypeUnificationRule {
	canUnify(t1, t2) {
		return t1 instanceof _types.ObjectType && t2 instanceof _types.ObjectType && t1.constructor === t2.constructor;
	}

	unify(t1, t2, unificator) {
		const smaller = t1.properties.size <= t2.properties.size ? t1 : t2;
		const larger = t1 === smaller ? t2 : t1;

		const commonProperties = smaller.properties.withMutations(map => {
			//noinspection JSAnnotator
			for (const _ref of map) {
				var _ref2 = (0, _slicedToArray3.default)(_ref, 2);

				const member = _ref2[0];
				const type = _ref2[1];

				const otherType = larger.properties.get(member);
				if (otherType) {
					const unified = unificator.unify(type, otherType);
					if (unified !== type) {
						map.set(member, unified);
					}
				} else {
					map.delete(member);
				}
			}
		});

		if (_immutable2.default.is(commonProperties, smaller.properties)) {
			return smaller;
		}

		return t1.withProperties(commonProperties);
	}
}

exports.RecordTypeUnificationRule = RecordTypeUnificationRule;
exports.default = RecordTypeUnificationRule;
//# sourceMappingURL=record-type-unification-rule.js.map
