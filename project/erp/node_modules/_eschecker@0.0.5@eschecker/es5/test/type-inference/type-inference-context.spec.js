"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _typeInferenceContext = require("../../lib/type-inference/type-inference-context");

var _symbol = require("../../lib/semantic-model/symbol");

var _types = require("../../lib/semantic-model/types");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _program = require("../../lib/semantic-model/program");

var _controlFlowGraph = require("../../lib/cfg/control-flow-graph");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("TypeInferenceContext", function () {
	let program;

	beforeEach(function () {
		program = new _program.Program();
	});

	describe("getType", function () {
		it("returns the type for the given symbol from the underlining type environment", function () {
			// arrange
			const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Identifier);
			const xType = _types.StringType.create();
			const typeEnvironment = new _typeEnvironment.TypeEnvironment().setType(x, xType);
			const context = new _typeInferenceContext.TypeInferenceContext(program, typeEnvironment);

			// assert
			(0, _chai.expect)(context.getType(x)).to.equal(xType);
		});
	});

	describe("setType", function () {
		it("sets the type in the type environment", function () {
			// arrange
			const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Identifier);
			const xType = _types.StringType.create();
			const context = new _typeInferenceContext.TypeInferenceContext(program);

			// act
			context.setType(x, xType);

			// assert
			(0, _chai.expect)(context.typeEnvironment.getType(x)).to.equal(xType);
		});
	});

	describe("substitute", function () {
		it("calls substitute on the type environment", function () {
			// arrange
			const t1 = _types.StringType.create();
			const t2 = _types.NumberType.create();
			const typeEnvironment = new _typeEnvironment.TypeEnvironment();
			context = new _typeInferenceContext.TypeInferenceContext(program, typeEnvironment);

			_sinon2.default.spy(typeEnvironment, "substitute");

			// act
			context.substitute(t1, t2);

			// assert
			_sinon2.default.assert.calledWith(typeEnvironment.substitute, t1, t2);
		});
	});

	describe("getSymbol", function () {
		it("returns the symbol from the programs symbol table", function () {
			// arrange
			const node = {};
			const symbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);

			program.symbolTable.setSymbol(node, symbol);

			const context = new _typeInferenceContext.TypeInferenceContext(program);

			// act, assert
			(0, _chai.expect)(context.getSymbol(node)).to.equal(symbol);
		});
	});

	describe("getCfg", function () {
		it("returns the cfg determined by program.getCfg", function () {
			// arrange
			const node = {};
			const cfg = new _controlFlowGraph.ControlFlowGraph();

			_sinon2.default.stub(program, "getCfg").returns(cfg);

			const context = new _typeInferenceContext.TypeInferenceContext(program);

			// act, assert
			(0, _chai.expect)(context.getCfg(node)).to.equal(cfg);
		});
	});
});
//# sourceMappingURL=type-inference-context.spec.js.map
