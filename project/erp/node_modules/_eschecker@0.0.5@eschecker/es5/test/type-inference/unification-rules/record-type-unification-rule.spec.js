"use strict";

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _chai = require("chai");

var _recordTypeUnificationRule = require("../../../lib/type-inference/unification-rules/record-type-unification-rule");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

var _typeUnificator = require("../../../lib/type-inference/type-unificator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("RecordTypeUnificationRule", function () {
	let unificator, rule, sandbox, name, age, lastName;

	beforeEach(function () {
		sandbox = _sinon2.default.sandbox.create();

		unificator = new _typeUnificator.TypeUnificator([]);
		rule = new _recordTypeUnificationRule.RecordTypeUnificationRule();
		name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
		lastName = new _symbol.Symbol("lastName", _symbol.SymbolFlags.Property);
		age = new _symbol.Symbol("age", _symbol.SymbolFlags.Property);
	});

	afterEach(function () {
		sandbox = _sinon2.default.sandbox.restore();
	});

	describe("canUnify", function () {
		it("returns true for two record types with equal constructors", function () {
			// arrange
			const record = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const otherRecord = record.addProperty(lastName, _types.StringType.create());

			// act, assert
			(0, _chai.expect)(rule.canUnify(record, otherRecord)).to.be.true;
		});

		it("returns false if the two record types are not from the same type", function () {
			// arrange
			const record = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const otherRecord = _types.RecordType.create(_types.RecordType, []);

			// act, assert
			(0, _chai.expect)(rule.canUnify(record, otherRecord)).to.be.false;
		});

		it("returns false if only one of both types is an object type", function () {
			// arrange
			const record = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(rule.canUnify(record, _types.StringType.create())).to.be.false;
			(0, _chai.expect)(rule.canUnify(_types.StringType.create(), record)).to.be.false;
		});
	});

	describe("unify", function () {
		it("returns the subset with the common properties of the two records", function () {
			// arrange
			const withAge = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const withLastName = _types.ObjectType.create([[name, _types.StringType.create()], [lastName, _types.StringType.create()]]);

			sandbox.stub(unificator, "unify").returnsArg(0);

			// act
			const unified = rule.unify(withAge, withLastName, unificator);

			// assert
			(0, _chai.expect)(unified.hasProperty(name)).to.be.true;
			(0, _chai.expect)(unified.getType(name)).to.be.instanceOf(_types.StringType);
			(0, _chai.expect)(unified.hasProperty(age)).to.be.false;
			(0, _chai.expect)(unified.hasProperty(lastName)).to.be.false;
		});

		it("returns the same record instance if one record is exactly the subset of the other record", function () {
			// arrange
			const smaller = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const larger = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()], [lastName, _types.StringType.create()]]);

			sandbox.stub(unificator, "unify").returnsArg(0);

			// act
			const unified = rule.unify(smaller, larger, unificator);

			// assert
			(0, _chai.expect)(unified).to.equal(smaller);
		});

		it("unifies the types of the properties", function () {
			// arrange
			const withNameAsNull = _types.ObjectType.create([[name, _types.NullType.create()], [lastName, _types.StringType.create()]]);
			const withNameAsString = _types.ObjectType.create([[name, _types.StringType.create()], [lastName, _types.StringType.create(), [age, _types.NumberType.create()]]]);

			sandbox.stub(unificator, "unify").withArgs(_sinon2.default.match.instanceOf(_types.StringType), _sinon2.default.match.instanceOf(_types.StringType)).returnsArg(0).withArgs(_sinon2.default.match.instanceOf(_types.NullType), _sinon2.default.match.instanceOf(_types.StringType)).returns(_types.MaybeType.of(_types.StringType.create()));

			// act
			const unified = rule.unify(withNameAsNull, withNameAsString, unificator);

			// assert
			(0, _chai.expect)(unified.getType(name)).to.be.instanceOf(_types.MaybeType);
			(0, _chai.expect)(unified.getType(name).of).to.be.instanceOf(_types.StringType);
		});
	});
});
//# sourceMappingURL=record-type-unification-rule.spec.js.map
