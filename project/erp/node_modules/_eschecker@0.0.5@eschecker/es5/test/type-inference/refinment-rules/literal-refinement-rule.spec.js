"use strict";

var _chai = require("chai");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _literalRefinementRule = require("../../../lib/type-inference/refinement-rules/literal-refinement-rule");

var _types = require("../../../lib/semantic-model/types");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

describe("LiteralRefinementRule", function () {
	let rule;

	beforeEach(function () {
		rule = new _literalRefinementRule.LiteralRefinementRule();
	});

	describe("canRefine", function () {
		it("returns true for a string literal", function () {
			// arrange
			const stringLiteral = t.stringLiteral("abcd");

			// act, assert
			(0, _chai.expect)(rule.canRefine(stringLiteral)).to.be.true;
		});

		it("returns true for a number literal", function () {
			// arrange
			const numberLiteral = t.numericLiteral(10);

			// act, assert
			(0, _chai.expect)(rule.canRefine(numberLiteral)).to.be.true;
		});

		it("returns true for the null literal", function () {
			// arrange
			const nullLiteral = t.nullLiteral();

			// act, assert
			(0, _chai.expect)(rule.canRefine(nullLiteral)).to.be.true;
		});

		it("returns true for a boolean literal", function () {
			// arrange
			const boolLiteral = t.booleanLiteral(false);

			// act, assert
			(0, _chai.expect)(rule.canRefine(boolLiteral)).to.be.true;
		});

		it("returns false in the other cases", function () {
			// arrange
			const identifier = t.identifier("x");

			// act, assert
			(0, _chai.expect)(rule.canRefine(identifier)).to.be.false;
		});
	});

	describe("refine", function () {
		it("returns a StringType for a string literal", function () {
			// arrange
			const stringLiteral = t.stringLiteral("abcd");

			// act, assert
			(0, _chai.expect)(rule.refine(stringLiteral)).to.be.instanceOf(_types.StringType);
		});

		it("returns a NumberType for a number literal", function () {
			// arrange
			const nullLiteral = t.numericLiteral(3);

			// act, assert
			(0, _chai.expect)(rule.refine(nullLiteral)).to.be.instanceOf(_types.NumberType);
		});

		it("returns a BooleanType for a boolean literal", function () {
			// arrange
			const booleanLiteral = t.booleanLiteral(true);

			// act, assert
			(0, _chai.expect)(rule.refine(booleanLiteral)).to.be.instanceOf(_types.BooleanType);
		});

		it("returns a NullType for a null literal", function () {
			// arrange
			const nullLiteral = t.nullLiteral();

			// act, assert
			(0, _chai.expect)(rule.refine(nullLiteral)).to.be.instanceOf(_types.NullType);
		});
	});
});
//# sourceMappingURL=literal-refinement-rule.spec.js.map
