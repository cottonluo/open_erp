"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.BinaryExpressionRefinementRule = undefined;

var _binaryOperators = require("./binary-operators");

var _binaryOperators2 = _interopRequireDefault(_binaryOperators);

var _typeInferenceError = require("../type-inference-error");

var _typeInferenceError2 = _interopRequireDefault(_typeInferenceError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Refinement rule for binary expressions like 5 + 2
 * @implements {RefinementRule}
 */
class BinaryExpressionRefinementRule {
	canRefine(node) {
		return node.type === "BinaryExpression";
	}

	refine(node, context) {
		if (!(node.operator in _binaryOperators2.default)) {
			throw new _typeInferenceError2.default(`The binary operator ${ node.operator } is not supported.`, node);
		}
		const operator = _binaryOperators2.default[node.operator];

		// Use fresh types. This operations should not change the effective type of a variable. If the variable was null before, then it should still be null.
		const leftExpressionType = context.infer(node.left).fresh();
		const rightExpressionType = context.infer(node.right).fresh();
		return operator.refine(leftExpressionType, rightExpressionType, (t1, t2) => context.unify(t1, t2, node));
	}
}

exports.BinaryExpressionRefinementRule = BinaryExpressionRefinementRule;
exports.default = BinaryExpressionRefinementRule;
//# sourceMappingURL=binary-expression-refinement-rule.js.map
