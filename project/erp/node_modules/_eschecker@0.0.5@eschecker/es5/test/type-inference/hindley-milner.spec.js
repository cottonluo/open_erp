"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _hindleyMilner = require("../../lib/type-inference/hindley-milner");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _typeUnificator = require("../../lib/type-inference/type-unificator");

var _program = require("../../lib/semantic-model/program");

var _types = require("../../lib/semantic-model/types");

var _hindleyMilnerContext = require("../../lib/type-inference/hindley-milner-context");

var _symbol = require("../../lib/semantic-model/symbol");

var _typeInferenceContext = require("../../lib/type-inference/type-inference-context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("HindleyMilner", function () {
	let hindleyMilner, refineRule1, refineRule2, typeUnificator, program;

	beforeEach(function () {
		program = new _program.Program();
		refineRule1 = { canRefine: _sinon2.default.stub(), refine: _sinon2.default.stub() };
		refineRule2 = { canRefine: _sinon2.default.stub(), refine: _sinon2.default.stub() };
		typeUnificator = new _typeUnificator.TypeUnificator();
		hindleyMilner = new _hindleyMilner.HindleyMilner(typeUnificator, [refineRule1, refineRule2]);
	});

	describe("refinementRules", function () {
		it("uses the refinement rules passed in the constructor", function () {
			(0, _chai.expect)(hindleyMilner.refinementRules.toArray()).to.deep.equal([refineRule1, refineRule2]);
		});

		it("loads the refinment rules from the refinment-rules directory by default", function () {
			// act
			hindleyMilner = new _hindleyMilner.HindleyMilner(typeUnificator);

			// assert
			(0, _chai.expect)(hindleyMilner.refinementRules.toArray()).not.to.be.empty;
		});
	});

	describe("infer", function () {
		it("uses the refinement rule that can handle the given node type", function () {
			// arrange
			const node = {};
			refineRule1.canRefine.returns(false);
			refineRule2.canRefine.returns(true);
			refineRule2.refine.returns(_types.NumberType.create());

			// act
			const inferred = hindleyMilner.infer(node, new _hindleyMilnerContext.HindleyMilnerContext({}, new _typeInferenceContext.TypeInferenceContext(program)));

			// assert
			(0, _chai.expect)(inferred).to.be.instanceOf(_types.NumberType);
			_sinon2.default.assert.calledWith(refineRule2.refine, node, _sinon2.default.match.instanceOf(_hindleyMilnerContext.HindleyMilnerContext));
		});

		it("throws an exception if no rule can handle the given node", function () {
			// arrange
			const node = {};
			refineRule1.canRefine.returns(false);
			refineRule2.canRefine.returns(false);

			// act, assert
			(0, _chai.expect)(() => hindleyMilner.infer(node, new _typeInferenceContext.TypeInferenceContext(program))).to.throw("Type inference failure: There exists no refinement rule that can handle a node of type undefined");
		});

		it("throws an exception if more then one rule can handle the given node", function () {
			// arrange
			const node = {};
			refineRule1.canRefine.returns(true);
			refineRule2.canRefine.returns(true);

			// act, assert
			(0, _chai.expect)(() => hindleyMilner.infer(node, new _typeInferenceContext.TypeInferenceContext(program))).to.throw("Type inference failure: The refinement rule to use for a node of type undefined is ambiguous");
		});
	});

	describe("unify", function () {
		it("uses the passed in unificator to unify two types", function () {
			// arrange
			const t1 = _types.NumberType.create();
			const t2 = _types.NumberType.create();
			_sinon2.default.stub(typeUnificator, "unify").returns(t1);

			// act
			const result = hindleyMilner.unify(t1, t2, {}, new _typeInferenceContext.TypeInferenceContext(program));

			// assert
			_sinon2.default.assert.calledWith(typeUnificator.unify, t1, t2);
			(0, _chai.expect)(result).to.equal(t1);
		});

		it("substitutes the type t1 with the returned type if they are not equal", function () {
			// arrange
			const t1 = new _types.TypeVariable();
			const t2 = _types.NumberType.create();

			const context = new _typeInferenceContext.TypeInferenceContext(program);
			_sinon2.default.spy(context, "substitute");
			_sinon2.default.stub(typeUnificator, "unify").returns(t2);

			// act
			hindleyMilner.unify(t1, t2, {}, context);

			// assert
			_sinon2.default.assert.calledWith(context.substitute, t1, t2);
		});

		it("substitutes the type t2 with the returned type after unification if they are not equal", function () {
			// arrange
			const t2 = new _types.TypeVariable();
			const t1 = _types.NumberType.create();
			_sinon2.default.stub(typeUnificator, "unify").returns(t1);
			const context = new _typeInferenceContext.TypeInferenceContext(program);
			_sinon2.default.spy(context, "substitute");

			// act
			hindleyMilner.unify(t1, t2, {}, context);

			// assert
			_sinon2.default.assert.calledWith(context.substitute, t2, t1);
		});

		it("substitutes the type variable t1 with the type variable t2 after unification", function () {
			// arrange
			const t1 = new _types.TypeVariable();
			const t2 = new _types.TypeVariable();
			_sinon2.default.stub(typeUnificator, "unify").returns(t2);
			const context = new _typeInferenceContext.TypeInferenceContext(program);
			_sinon2.default.spy(context, "substitute");

			// act
			hindleyMilner.unify(t1, t2, {}, context);

			// assert
			_sinon2.default.assert.calledWith(context.substitute, t1, t2);
		});

		it("catches the unification errors and propagates the error as type inference error", function () {
			// arrange
			const t1 = _types.NumberType.create();
			const t2 = _types.NumberType.create();
			_sinon2.default.stub(typeUnificator, "unify").throws(new _typeUnificator.UnificationError(t1, t2, "Ooops..."));

			// act, assert
			(0, _chai.expect)(() => hindleyMilner.unify(t1, t2, {}, new _typeInferenceContext.TypeInferenceContext(program))).to.throw("Type inference failure: Unification for type 'number' and 'number' failed because Ooops...");
		});
	});

	describe("mergeWithTypeEnvironments", function () {
		it("unions the definitions of both type environments into a new returned type environment", function () {
			// arrange
			const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Variable);

			const env1 = new _typeEnvironment.TypeEnvironment().setType(name, _types.StringType.create());
			const env2 = new _typeEnvironment.TypeEnvironment().setType(age, _types.NumberType.create());

			const context = new _typeInferenceContext.TypeInferenceContext(program, env1);

			// act
			hindleyMilner.mergeWithTypeEnvironments([env2], {}, context);

			// assert
			(0, _chai.expect)(context.getType(name)).to.be.instanceOf(_types.StringType);
			(0, _chai.expect)(context.getType(age)).to.be.instanceOf(_types.NumberType);
		});

		it("unifies the types of conflicting definitions for the same symbol", function () {
			// arrange
			const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Variable);
			const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Variable);

			const env1 = new _typeEnvironment.TypeEnvironment().setType(name, _types.StringType.create());
			const env2 = new _typeEnvironment.TypeEnvironment().setType(age, _types.NumberType.create()).setType(name, _types.NullType.create());

			_sinon2.default.stub(typeUnificator, "unify").withArgs(_sinon2.default.match.instanceOf(_types.NullType), _sinon2.default.match.instanceOf(_types.StringType)).returns(_types.MaybeType.of(_types.StringType.create()));

			const context = new _typeInferenceContext.TypeInferenceContext(program, env1);

			// act
			hindleyMilner.mergeWithTypeEnvironments([env2], {}, context);

			// assert
			(0, _chai.expect)(context.getType(name)).to.be.instanceOf(_types.MaybeType);
			(0, _chai.expect)(context.getType(age)).to.be.instanceOf(_types.NumberType);
		});
	});
});
//# sourceMappingURL=hindley-milner.spec.js.map
