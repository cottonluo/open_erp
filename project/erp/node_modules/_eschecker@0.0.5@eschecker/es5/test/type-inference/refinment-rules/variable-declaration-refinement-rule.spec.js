"use strict";

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _chai = require("chai");

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _variableDeclarationRefinementRule = require("../../../lib/type-inference/refinement-rules/variable-declaration-refinement-rule");

var _hindleyMilnerContext = require("../../../lib/type-inference/hindley-milner-context");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

var _typeInferenceContext = require("../../../lib/type-inference/type-inference-context");

var _program = require("../../../lib/semantic-model/program");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("VariableDeclarationRefinementRule", function () {
	let rule, context, program;

	beforeEach(function () {
		program = new _program.Program();
		context = new _hindleyMilnerContext.HindleyMilnerContext(null, new _typeInferenceContext.TypeInferenceContext(program));
		rule = new _variableDeclarationRefinementRule.VariableDeclarationRefinementRule();
	});

	describe("canRefine", function () {
		it("returns true for a variable declarator", function () {
			// arrange
			const declarator = t.variableDeclarator(t.identifier("x"), t.stringLiteral("abd"));

			// act, assert
			(0, _chai.expect)(rule.canRefine(declarator)).to.be.true;
		});

		it("returns true for a variable declaration", function () {
			// arrange
			const declaration = t.variableDeclaration("let", [t.variableDeclarator(t.identifier("x"), t.stringLiteral("abd"))]);

			// act, assert
			(0, _chai.expect)(rule.canRefine(declaration)).to.be.true;
		});

		it("returns false for other types", function () {
			(0, _chai.expect)(rule.canRefine(t.stringLiteral("abcd"))).to.be.false;
		});
	});

	describe("refine", function () {
		describe("VariableDeclarator", function () {
			it("returns the type of the init expression if the declarator has an init expression", function () {
				// arrange
				const identifier = t.identifier("x");
				const declarator = t.variableDeclarator(identifier, t.stringLiteral("abcd"));

				const symbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(identifier, symbol);

				_sinon2.default.stub(context, "infer").returns(_types.StringType.create());

				// act
				const refined = rule.refine(declarator, context);

				// assert
				(0, _chai.expect)(refined).to.be.instanceOf(_types.StringType);
			});

			it("updates the type of the variable declarator in the type environment if the declarator has an init expression", function () {
				// arrange
				const identifier = t.identifier("x");
				const declarator = t.variableDeclarator(identifier, t.stringLiteral("abcd"));
				const symbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(identifier, symbol);

				_sinon2.default.stub(context, "infer").returns(_types.StringType.create());

				// act
				rule.refine(declarator, context);

				// assert
				(0, _chai.expect)(context.getType(symbol)).to.be.instanceOf(_types.StringType);
			});

			it("sets a fresh type as the type of the variable", function () {
				// arrange
				const identifier = t.identifier("x");
				const declarator = t.variableDeclarator(identifier, t.stringLiteral("abcd"));
				const symbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(identifier, symbol);
				const xT = _types.TypeVariable.create();

				_sinon2.default.stub(context, "infer").returns(xT);

				// act
				rule.refine(declarator, context);

				// assert
				(0, _chai.expect)(context.getType(symbol)).to.be.instanceOf(_types.TypeVariable).and.not.to.equal(xT);
			});

			it("returns VoidType if the declarator has no init expression", function () {
				// arrange
				const identifier = t.identifier("x");
				const declarator = t.variableDeclarator(identifier);

				const symbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(identifier, symbol);

				// act
				const refined = rule.refine(declarator, context);

				// assert
				(0, _chai.expect)(refined).to.be.instanceOf(_types.VoidType);
				(0, _chai.expect)(context.getType(symbol)).to.be.instanceOf(_types.VoidType);
			});
		});

		describe("VariableDeclaration", function () {
			it("returns VoidType", function () {
				// arrange
				const declaration = t.variableDeclaration("let", [t.variableDeclarator(t.identifier("x"), t.stringLiteral("abd"))]);
				_sinon2.default.stub(context, "infer").returns(_types.StringType.create());
				_sinon2.default.stub(context, "getSymbol").returns(new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));
				_sinon2.default.stub(context, "setType");

				// act, assert
				(0, _chai.expect)(rule.refine(declaration, context)).to.be.instanceOf(_types.VoidType);
			});

			it("infers the types of all variable declarators in this variable declaration", function () {
				// arrange
				_sinon2.default.stub(context, "infer");
				_sinon2.default.stub(context, "setType");
				_sinon2.default.stub(context, "getSymbol");

				const x = t.variableDeclarator(t.identifier("x"), t.stringLiteral("abcd"));
				const xSymbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				context.getSymbol.withArgs(x.id).returns(xSymbol);
				context.infer.withArgs(x.init).returns(_types.StringType.create());

				const y = t.variableDeclarator(t.identifier("y"), t.numericLiteral(5));
				const ySymbol = new _symbol.Symbol("y", _symbol.SymbolFlags.Variable);
				context.getSymbol.withArgs(y.id).returns(ySymbol);
				context.infer.withArgs(y.init).returns(_types.NumberType.create());

				const declaration = t.variableDeclaration("let", [x, y]);

				// act
				const refined = rule.refine(declaration, context);

				// assert
				_sinon2.default.assert.calledWith(context.setType, xSymbol, _sinon2.default.match.instanceOf(_types.StringType));
				_sinon2.default.assert.calledWith(context.setType, ySymbol, _sinon2.default.match.instanceOf(_types.NumberType));

				(0, _chai.expect)(refined).to.be.instanceOf(_types.VoidType);
			});
		});
	});
});
//# sourceMappingURL=variable-declaration-refinement-rule.spec.js.map
