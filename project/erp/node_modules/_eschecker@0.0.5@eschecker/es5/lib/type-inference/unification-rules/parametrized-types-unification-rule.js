"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ParametrizedTypeUnificationRule = undefined;

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _immutable = require("immutable");

var _immutable2 = _interopRequireDefault(_immutable);

var _parametrizedType = require("../../semantic-model/types/parametrized-type");

var _typeUnificator = require("../type-unificator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Unification rule that unifies two parametrized types that are from the same type.
 * Unification of a parametrized type fails if the instances have a different count of type parameters or if any
 * type parameter cannot be unified.
 *
 * @implements {BaseTypeUnificationRule}
 */
class ParametrizedTypeUnificationRule {
	canUnify(t1, t2) {
		return t1.isSameType(t2) && t1 instanceof _parametrizedType.ParametrizedType;
	}

	unify(t1, t2, unificator) {
		if (t1.typeParameters.length !== t2.typeParameters.length) {
			throw new _typeUnificator.UnificationError(t1, t2, "the parametrized types have a different number of type parameters and therefore cannot be unified");
		}

		const oldTypeParameters = _immutable2.default.fromJS(t1.typeParameters);
		const newTypeParameters = oldTypeParameters.zip(t2.typeParameters).map(_ref => {
			var _ref2 = (0, _slicedToArray3.default)(_ref, 2);

			let x = _ref2[0];
			let y = _ref2[1];
			return unificator.unify(x, y);
		});
		if (_immutable2.default.is(newTypeParameters, oldTypeParameters)) {
			return t1;
		}

		return t1.withTypeParameters(newTypeParameters);
	}
}

exports.ParametrizedTypeUnificationRule = ParametrizedTypeUnificationRule;
exports.default = ParametrizedTypeUnificationRule;
//# sourceMappingURL=parametrized-types-unification-rule.js.map
