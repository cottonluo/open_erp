"use strict";

var _chai = require("chai");

var _scope = require("../../lib/semantic-model/scope");

var _scope2 = _interopRequireDefault(_scope);

var _symbol = require("../../lib/semantic-model/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("Scope", function () {
	it("is empty by default", function () {
		// act
		const scope = new _scope2.default(null);

		// assert
		(0, _chai.expect)(Array.from(scope.symbols)).to.be.empty;
	});

	describe("addSymbol", function () {
		it("adds the given symbol", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);

			// act
			scope.addSymbol(symbol);

			// assert
			(0, _chai.expect)(Array.from(scope.symbols)).to.contain(symbol);
		});

		it("throws when the given symbol already exists in the given scope", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			// act, assert
			(0, _chai.expect)(() => scope.addSymbol(new _symbol2.default("x", _symbol.SymbolFlags.FunctionScopedVariable))).to.throw;
		});

		it("does not throw if a symbol shadows a symbol from a parent scope", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			const childScope = scope.createChild();

			// act, assert
			(0, _chai.expect)(() => childScope.addSymbol(new _symbol2.default("x", _symbol.SymbolFlags.FunctionScopedVariable))).not.to.throw;
		});
	});

	describe("hasOwnSymbol", function () {
		it("returns false if the scope does not contain a symbol with the given name", function () {
			const scope = new _scope2.default(null);

			// act, assert
			(0, _chai.expect)(scope.hasOwnSymbol("x")).to.be.false;
		});

		it("returns true if the scope contains a symbol with the given name", function () {
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			// act, assert
			(0, _chai.expect)(scope.hasOwnSymbol("x")).to.be.true;
		});

		it("returns false if only the parent scope contains a symbol with the given name", function () {
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			const childScope = scope.createChild();

			// act, assert
			(0, _chai.expect)(childScope.hasOwnSymbol("x")).to.be.false;
		});
	});

	describe("hasSymbol", function () {
		it("returns false if the scope does not contain a symbol with the given name", function () {
			const scope = new _scope2.default(null);

			// act, assert
			(0, _chai.expect)(scope.hasSymbol("x")).to.be.false;
		});

		it("returns true if the scope contains a symbol with the given name", function () {
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			// act, assert
			(0, _chai.expect)(scope.hasSymbol("x")).to.be.true;
		});

		it("returns true if the parent scope contains a symbol with the given name", function () {
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			const childScope = scope.createChild();

			// act, assert
			(0, _chai.expect)(childScope.hasSymbol("x")).to.be.true;
		});
	});

	describe("symbols", function () {
		it("returns only the symbols defined in this scope", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			const childScope = scope.createChild();
			const ySymbol = new _symbol2.default("y", _symbol.SymbolFlags.FunctionScopedVariable);
			childScope.addSymbol(ySymbol);

			// assert
			(0, _chai.expect)(Array.from(childScope.symbols)).to.deep.equal([ySymbol]);
		});
	});

	describe("getAllSymbols", function () {
		it("returns the symbols in this and from the parent scopes", function () {
			// arrange
			const scope = new _scope2.default(null);
			const xSymbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(xSymbol);

			const childScope = scope.createChild();
			const ySymbol = new _symbol2.default("y", _symbol.SymbolFlags.FunctionScopedVariable);
			childScope.addSymbol(ySymbol);

			// assert
			(0, _chai.expect)(Array.from(childScope.getAllSymbols())).to.deep.equal([ySymbol, xSymbol]);
		});
	});

	describe("isGlobal", function () {
		it("returns true if the scope has no parent scope", function () {
			// arrange
			const scope = new _scope2.default();

			// assert
			(0, _chai.expect)(scope.isGlobal).to.be.true;
		});

		it("is false if the scope has a parent scope", function () {
			// arrange
			const globalScope = new _scope2.default();
			const childScope = globalScope.createChild();

			// assert
			(0, _chai.expect)(childScope.isGlobal).to.be.false;
		});
	});

	describe("resolveSymbol", function () {
		it("resolves the symbol with the given name", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			// act, assert
			(0, _chai.expect)(scope.resolveSymbol("x")).to.equal(symbol);
		});

		it("resolves symbols defined in the parent scope", function () {
			// arrange
			const scope = new _scope2.default(null);
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(symbol);

			const childScope = scope.createChild();

			// act, assert
			(0, _chai.expect)(childScope.resolveSymbol("x")).to.equal(symbol);
		});

		it("resolves the symbol from the nearest scope if the symbol shadows a symbol from a parent scope", function () {
			// arrange
			const scope = new _scope2.default(null);
			const shadowedSymbol = new _symbol2.default("x", _symbol.SymbolFlags.BlockScopedVariable);
			scope.addSymbol(shadowedSymbol);

			const childScope = scope.createChild();
			const shadowingSymbol = new _symbol2.default("x", _symbol.SymbolFlags.FunctionScopedVariable);

			childScope.addSymbol(shadowingSymbol);

			// act, assert
			(0, _chai.expect)(childScope.resolveSymbol("x")).to.equal(shadowingSymbol);
		});
	});

	describe("createChild", function () {
		it("returns a new scope", function () {
			// arrange
			const globalScope = new _scope2.default();

			// act
			const child = globalScope.createChild();

			// assert
			(0, _chai.expect)(child).not.to.be.null.and.not.to.equal(globalScope);
		});

		it("sets the parent scope to the scope on which the function has been invoked", function () {
			// arrange
			const globalScope = new _scope2.default();

			// act
			const child = globalScope.createChild();

			// assert
			(0, _chai.expect)(child).with.property("parent").that.equals(globalScope);
		});
	});
});
//# sourceMappingURL=scope.spec.js.map
