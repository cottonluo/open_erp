"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ArrayExpressionRefinementRule = undefined;

var _types = require("../../semantic-model/types");

var _typeUnificator = require("../type-unificator");

var _typeInferenceError = require("../type-inference-error");

/**
 * Refinement rule for an array expression
 * @implements {RefinementRule}
 */
class ArrayExpressionRefinementRule {
	canRefine(node) {
		return node.type === "ArrayExpression";
	}

	refine(node, context) {
		let elementType = node.elements.reduce((arrayType, element) => this._unifyElementType(element, arrayType, context), _types.TypeVariable.create());

		return _types.ArrayType.of(elementType);
	}

	_unifyElementType(element, arrayType, context) {
		const elementType = context.infer(element, context);
		try {
			return context.unify(elementType, arrayType, element);
		} catch (e) {
			// that's ugly... but unification fails if there is no unification rule
			// there is no unification rule for number and string, but in this case the array should be of type any
			if (e instanceof _typeInferenceError.TypeInferenceError && e.cause instanceof _typeUnificator.NotUnifiableError) {
				return _types.AnyType.create();
			}

			throw e;
		}
	}
}

exports.ArrayExpressionRefinementRule = ArrayExpressionRefinementRule;
exports.default = ArrayExpressionRefinementRule;
//# sourceMappingURL=array-expression-refinement-rule.js.map
