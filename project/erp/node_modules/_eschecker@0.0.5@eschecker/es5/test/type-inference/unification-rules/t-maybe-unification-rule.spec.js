"use strict";

var _chai = require("chai");

var _tMaybeUnificationRule = require("../../../lib/type-inference/unification-rules/t-maybe-unification-rule");

var _tMaybeUnificationRule2 = _interopRequireDefault(_tMaybeUnificationRule);

var _index = require("../../../lib/semantic-model/types/index");

var _typeUnificator = require("../../../lib/type-inference/type-unificator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("TMaybeUnificationRule", function () {
	let rule;
	let unificator;

	beforeEach(function () {
		rule = new _tMaybeUnificationRule2.default();
		unificator = new _typeUnificator.TypeUnificator([rule]);
	});

	describe("canUnify", function () {
		it("returns true if t1 is a maybe type and t2 is another type", function () {
			(0, _chai.expect)(rule.canUnify(_index.MaybeType.of(new _index.Type("number")), new _index.Type("number"))).to.be.true;
		});

		it("returns true if t1 is another type and t2 is maybe type", function () {
			(0, _chai.expect)(rule.canUnify(new _index.Type("number"), _index.MaybeType.of(new _index.Type("number")))).to.be.true;
		});

		it("returns false if neither t1 nor t2 are a maybe type", function () {
			(0, _chai.expect)(rule.canUnify(new _index.Type("number"), new _index.Type("string"))).to.be.false;
		});

		it("returns false if one type is a maybe type and the other is the null type (this case is handled by null-maybe-unification)", function () {
			(0, _chai.expect)(rule.canUnify(_index.MaybeType.of(new _index.Type("number")), _index.NullType.create())).to.be.false;
		});
	});

	describe("unify", function () {
		it("returns the maybe type", function () {
			// arrange
			const maybe = _index.MaybeType.of(new _index.Type("number"));

			// act, assert
			(0, _chai.expect)(rule.unify(maybe, new _index.Type("number"), unificator)).to.equal(maybe);
		});

		it("fails if MaybeType.of cannot be unified with the other type", function () {
			// arrange
			const maybe = _index.MaybeType.of(_index.NumberType.create("number"));

			// act, assert
			(0, _chai.expect)(() => rule.unify(_index.StringType.create(), maybe, unificator)).to.throw("Unification for type 'string' and 'number' failed because there exists no rule that can be used to unify the given types.");
		});
	});
});
//# sourceMappingURL=t-maybe-unification-rule.spec.js.map
