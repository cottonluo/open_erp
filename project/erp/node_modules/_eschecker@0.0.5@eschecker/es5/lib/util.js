"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.globRequire = globRequire;
exports.globRequireInstances = globRequireInstances;
exports.createTraverseVisitorWrapper = createTraverseVisitorWrapper;
exports.createLabelForNode = createLabelForNode;

var _glob = require("glob");

var _glob2 = _interopRequireDefault(_glob);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _babelGenerator = require("babel-generator");

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _lodash = require("lodash");

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Requires all files that match the passed in pattern
 * @param {String} pattern string pattern that the files need to match to be required. Path is relative to the passed in module
 * @param {Module} module module to which the path should be resolved relative.
 * @returns {Iterator} an iterator over the loaded modules
 */
function* globRequire(pattern, module) {
	for (const match of _glob2.default.sync(pattern, { cwd: _path2.default.dirname(module.filename) })) {
		yield module.require(match);
	}
}

/**
 * Requires all files that match the given glob pattern and creates an instance of the default object.
 * @param {string} pattern the glob pattern
 * @param {Module} module module that is used to resolve the paths.
 * @param [args] optional arguments that are passed directly to the constructor
 * @returns {Iterator} an iterator over the created instances
 */
function* globRequireInstances(pattern, module) {
	for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		args[_key - 2] = arguments[_key];
	}

	for (const requiredModule of globRequire(pattern, module)) {
		yield new requiredModule.default(...args);
	}
}

/**
 * Verifies the function of a visitor object. The allowed methods on a visitor object are
 * - defaultHandler
 * - enterNodeType and exitNodeType
 * - methods prefixed with _
 *
 * @param visitorObject the visitor object to verify
 */
function checkVisitorObjectFunctions(visitorObject) {
	for (const f of (0, _lodash.functions)(visitorObject)) {
		if ((0, _lodash.startsWith)(f, "_") || f === "defaultHandler") {
			continue;
		}

		const cleanedMethodName = (0, _lodash.startsWith)(f, "enter") ? (0, _lodash.trimStart)(f, "enter") : (0, _lodash.trimStart)(f, "exit");
		if (f === cleanedMethodName) {
			_assert2.default.fail(`Visitor methods need to be prefixed with enter or exit, following by the node type, method ${ f } is not prefixed`);
		}

		if (!(cleanedMethodName in t.VISITOR_KEYS)) {
			_assert2.default.fail(`Unknown Node type '${ cleanedMethodName }' for visitor`);
		}
	}
}

/**
 * The function wraps the passed in object in a way that it can be used as babel-traverse-visitor.
 * Babel traverse adds various requirements to the visitor object that can lead to bad design. The wrapper reverses
 * this limitation and allows an almost arbitrary object as visitor, also objects that are instances from a class.
 * The wrapper overcomes the following limitations
 *
 * - The wrappers ensures that the this context of a handler function is not changed to the visiting context. The wrapper passes
 *   the context as separate handler argument (Path, Context).
 * - The wrapper allows private methods starting with an underscore.
 * - The wrapper allows the registration of a default handler that is called always when no more specific handler exists.
 *   The default handler is a method called defaultHandler that accepts the path and the context
 *
 * The wrapper has one limitation. To be able to support the defaultHandler functionality, it cannot support aliases
 * @param visitorObject the object that should be wrapped as babel-traverse conform visitor.
 * @returns {Object}the visitor object that can be used with babel-traverse
 */
function createTraverseVisitorWrapper(visitorObject) {
	checkVisitorObjectFunctions(visitorObject);

	const wrapper = {};
	let defaultHandler;

	if (visitorObject.defaultHandler) {
		defaultHandler = function (path) {
			visitorObject.defaultHandler(path, this);
		};
	} else {
		defaultHandler = function (path) {
			_assert2.default.fail(`Unhandled node type ${ path.node.type }.`);
		};
	}

	for (const type in t.VISITOR_KEYS) {
		const enterHandler = visitorObject[`enter${ type }`];
		const exitHandler = visitorObject[`exit${ type }`];

		if (enterHandler || exitHandler) {
			const enterCallback = function (path) {
				enterHandler.call(visitorObject, path, this);
			};
			const exitCallback = function (path) {
				exitHandler.call(visitorObject, path, this);
			};

			if (exitHandler) {
				wrapper[type] = { enter: enterCallback, exit: exitCallback };
			} else {
				wrapper[type] = enterCallback;
			}
		} else {
			wrapper[type] = defaultHandler;
		}
	}

	return wrapper;
}

/**
 * Generates a single line label for a statement by  using the code representation of the node but without any
 * child nodes.
 * @param {AstNode} node the node for which the label should be generated
 * @returns {string} a label for this node
 */
function createLabelForNode(node) {
	let label;

	function codeFor(node) {
		var _generate = (0, _babelGenerator2.default)(node, {
			retainLines: false,
			comments: false,
			quotes: "double"
		});

		const code = _generate.code;


		let result = code.replace(/"/g, "\\\"");

		if ((0, _lodash.endsWith)(result, ";")) {
			result = result.substring(0, result.length - 1);
		}
		if ((0, _lodash.includes)(result, "\n")) {
			result = result.split("\n")[0] + "...";
		}
		return result;
	}

	if (!node) {
		return "EOF";
	}

	if (t.isIfStatement(node)) {
		label = `if (${ codeFor(node.test) })`;
	} else if (t.isWhileStatement(node)) {
		label = `while (${ codeFor(node.test) })`;
	} else if (t.isForStatement(node)) {
		label = `for (${ codeFor(node.init) }, ${ codeFor(node.test) }, ${ codeFor(node.update) })`;
	} else if (t.isForInStatement(node)) {
		label = `for (${ codeFor(node.left) } in ${ codeFor(node.right) })`;
	} else if (t.isForOfStatement(node)) {
		label = `for (${ codeFor(node.left) } of ${ codeFor(node.right) })`;
	} else if (t.isDoWhileStatement(node)) {
		label = `do ... while(${ codeFor(node.test) })`;
	} else if (t.isSwitchStatement(node)) {
		label = `switch (${ codeFor(node.discriminant) })`;
	} else if (t.isSwitchCase(node)) {
		if (node.test) {
			label = `case ${ codeFor(node.test) }:`;
		} else {
			label = "default:";
		}
	} else if (t.isArrowFunctionExpression(node)) {
		const params = node.params.map(param => codeFor(param)).join(", ");
		label = `(${ params }) => ...`;
	} else if (t.isFunction(node)) {
		const params = node.params.map(param => codeFor(param)).join(", ");
		const name = node.id ? node.id.name : node.key ? node.key.name : "anonymous";
		label = `function ${ name } (${ params })`;
	} else if (t.isClassDeclaration(node)) {
		label = `class ${ codeFor(node.id) }`;
	} else if (t.isTryStatement(node)) {
		label = "try";
	} else if (t.isCatchClause(node)) {
		label = "catch";
	} else if (t.isBlockStatement(node)) {
		if (node.body.length === 0) {
			label = "{}";
		} else {
			label = "{ ... }";
		}
	} else {
		label = codeFor(node);
	}

	const lineOfCode = node && node.loc ? node.loc.start.line : "";

	return `${ lineOfCode } ${ label }`;
}
//# sourceMappingURL=util.js.map
