"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.HindleyMilnerDataFlowAnalysis = undefined;

var _immutable = require("immutable");

var _immutable2 = _interopRequireDefault(_immutable);

var _typeEnvironment = require("./type-environment");

var _typeEnvironment2 = _interopRequireDefault(_typeEnvironment);

var _workListDataFlowAnalysis = require("../data-flow-analysis/work-list-data-flow-analysis");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Data flow analysis that uses the Hindley milner algorithm to calculate the transfer for a statement.
 */
class HindleyMilnerDataFlowAnalysis extends _workListDataFlowAnalysis.WorkListDataFlowAnalysis {

	/**
  * Creates a new hindley milner data flow analysis
  * @param {TypeInferenceAnalysis} typeInferenceAnalysis the type inference analysis to use (e.g. forward or backward)
  * @param {TypeEnvironment} [typeEnvironment] the start type environment
     */
	constructor(typeInferenceAnalysis) {
		let typeEnvironment = arguments.length <= 1 || arguments[1] === undefined ? _typeEnvironment2.default.EMPTY : arguments[1];

		super();
		this.typeInferenceAnalysis = typeInferenceAnalysis;
		this.initTypeEnvironment = typeEnvironment;
	}

	createEmptyLattice() {
		return this.initTypeEnvironment;
	}

	transfer(node, inTypeEnvironment) {
		if (node === null) {
			// exit node
			return inTypeEnvironment;
		}

		const context = this.typeInferenceAnalysis.createHindleyMilnerContext(inTypeEnvironment);
		context.infer(node);
		return context.typeEnvironment;
	}

	joinBranches(head, tail, node) {
		return this.typeInferenceAnalysis.joinTypeEnvironments(head, tail, node || {});
	}

	areStatesEqual(x, y) {
		return _immutable2.default.is(x, y);
	}
}

exports.HindleyMilnerDataFlowAnalysis = HindleyMilnerDataFlowAnalysis;
exports.default = HindleyMilnerDataFlowAnalysis;
//# sourceMappingURL=hindley-milner-data-flow-analysis.js.map
