"use strict";

var _chai = require("chai");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

describe("RecordType", function () {
	const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
	const age = new _symbol.Symbol("age", _symbol.SymbolFlags.Property);

	describe("fresh", function () {
		it("returns a new instance that has the same properties", function () {
			// arrange
			const original = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act
			const fresh = original.fresh();

			// assert
			(0, _chai.expect)(fresh).not.to.equal(original);
			(0, _chai.expect)(fresh.properties).to.deep.equal(original.properties);
		});

		it("returns a new instance that has not the same id as the original one", function () {
			// arrange
			const original = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act
			const fresh = original.fresh();

			// assert
			(0, _chai.expect)(fresh.id).not.to.equal(original.id);
		});
	});

	describe("addProperty", function () {
		it("returns a new record that has a property with the given type and name", function () {
			// arrange
			const record = new _types.RecordType();

			// act
			const withProperty = record.addProperty(name, _types.StringType.create());

			// assert
			(0, _chai.expect)(withProperty).not.to.equal(record);
			(0, _chai.expect)(withProperty.hasProperty(name)).to.be.true;
			(0, _chai.expect)(withProperty.getType(name)).to.be.instanceOf(_types.StringType);
		});

		it("throws if a property with the given name already exists", function () {
			// arrange
			const record = createRecord([[name, _types.StringType.create()]]);

			// act, assert
			(0, _chai.expect)(() => record.addProperty(name, _types.StringType.create())).to.throw("AssertionError: A property with the name 'name' already exists");
		});
	});

	describe("hasProperty", function () {
		it("returns false if the record has no property with the given name", function () {
			(0, _chai.expect)(new _types.RecordType().hasProperty(name)).to.be.false;
		});

		// There's no way that it can now if it has the property or not, therefor just return true to not trigger errors
		it("returns true for a computed property", function () {
			(0, _chai.expect)(new _types.RecordType().hasProperty(_symbol.Symbol.COMPUTED)).to.be.true;
		});
	});

	describe("setType", function () {
		it("throws if no property with the given name exists", function () {
			(0, _chai.expect)(() => new _types.RecordType().setType(name, _types.StringType.create())).to.throw("AssertionError: property does not yet exist, to add new properties use add property");
		});

		it("returns a new record type where the symbol is associated with the new type", function () {
			const record = createRecord([[name, _types.NullType.create()]]);

			// act
			const changedRecord = record.setType(name, _types.StringType.create());

			// assert
			(0, _chai.expect)(changedRecord.getType(name)).to.be.instanceOf(_types.StringType);
		});

		it("returns any if a computed property is set", function () {
			// arrange
			const record = createRecord();

			// act, assert
			(0, _chai.expect)(record.setType(_symbol.Symbol.COMPUTED, _types.StringType.create())).to.be.instanceOf(_types.AnyType);
		});
	});

	describe("getType", function () {
		it("returns undefined if the record has no property with the given name", function () {
			(0, _chai.expect)(new _types.RecordType().getType(name)).to.be.undefined;
		});

		it("returns type any for computed properties", function () {
			(0, _chai.expect)(createRecord().getType(_symbol.Symbol.COMPUTED, _types.StringType.create())).to.be.instanceOf(_types.AnyType);
		});
	});

	describe("prettyName", function () {
		it("returns {} if the record has no properties", function () {
			(0, _chai.expect)(new _types.RecordType().prettyName).to.equal("{}");
		});

		it("returns an object literal where the key is the name of the property and the value is the type of the property", function () {
			const record = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(record.prettyName).to.equal("{name: string, age: number}");
		});
	});

	describe("containsType", function () {
		it("returns true if this and t2 are the same instances", function () {
			// arrange
			const t = new _types.RecordType();

			// act, assert
			(0, _chai.expect)(t.containsType(t)).to.be.true;
		});

		it("returns true if t2 is used as type property type", function () {
			// arrange
			const otherType = new _types.TypeVariable();

			const thisType = createRecord([[name, otherType]]);

			// act
			(0, _chai.expect)(thisType.containsType(otherType)).to.be.true;
		});

		it("returns false if t2 is not used inside a property type", function () {
			// arrange
			const otherType = new _types.TypeVariable();

			const thisType = createRecord([[name, _types.StringType.create()]]);

			// act
			(0, _chai.expect)(thisType.containsType(otherType)).to.be.false;
		});
	});

	describe("equals", function () {
		it("returns false if not both types are record types", function () {
			// arrange
			const t1 = new _types.RecordType();
			const t2 = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(t1.equals(t2)).to.be.false;
		});

		it("returns false if both records have not the same properties", function () {
			// arrange
			const lastName = new _symbol.Symbol("lastName", _symbol.SymbolFlags.Property);

			const t1 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const t2 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()], [lastName, _types.StringType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.equals(t2)).to.be.false;
		});

		it("returns false if both records have the same properties but with different types", function () {
			// arrange
			const t1 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const t2 = createRecord([[name, _types.StringType.create()], [age, _types.MaybeType.of(_types.NumberType.create())]]);

			// act, assert
			(0, _chai.expect)(t1.equals(t2)).to.be.false;
		});

		it("returns true if both records have the same properties with equal types", function () {
			// arrange
			const t1 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const t2 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.equals(t2)).to.be.true;
		});
	});

	describe("substitute", function () {
		it("replaces the types of the properties using the old type with the new type", function () {
			// arrange
			const oldType = new _types.TypeVariable();
			const newType = _types.StringType.create();

			const record = createRecord([[name, oldType], [age, _types.NumberType.create()]]);

			// act
			const substituted = record.substitute(oldType, newType);

			// assert
			(0, _chai.expect)(substituted.getType(name)).to.equal(newType);
		});

		it("returns the same object if no type has been replaced", function () {
			const record = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act
			const substituted = record.substitute(new _types.TypeVariable(), _types.StringType.create());

			// assert
			(0, _chai.expect)(substituted).to.equal(record);
		});
	});

	describe("isSubType", function () {
		it("returns true if the type has the same or more properties", function () {
			// arrange
			const t1 = createRecord([[name, _types.StringType.create()]]);
			const t2 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.isSubType(t2)).to.be.true;
		});

		it("returns true if the type has the same or more properties and the properties are subtypes", function () {
			// arrange
			const t1 = createRecord([[name, _types.MaybeType.of(_types.StringType.create())]]);
			const t2 = createRecord([[name, _types.NullType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.isSubType(t2)).to.be.true;
		});

		it("returns false if the types are not from the same kind (type)", function () {
			// arrange
			const t1 = createRecord([[name, _types.StringType.create()]]);
			const t2 = _types.ObjectType.create([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.isSubType(t2)).to.be.false;
		});

		it("returns false if a property type is not a sub type", function () {
			// arrange
			const t1 = createRecord([[name, _types.NullType.create()]]);
			const t2 = createRecord([[name, _types.MaybeType.of(_types.StringType.create())], [age, _types.NumberType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.isSubType(t2)).to.be.false;
		});

		it("returns false if the ssubtype does not have the same properties", function () {
			// arrange
			const t1 = createRecord([[name, _types.StringType.create()], [age, _types.NumberType.create()]]);
			const t2 = createRecord([[name, _types.StringType.create()]]);

			// act, assert
			(0, _chai.expect)(t1.isSubType(t2)).to.be.false;
		});
	});

	function createRecord(properties) {
		return _types.RecordType.create(_types.RecordType, properties);
	}
});
//# sourceMappingURL=record-type.spec.js.map
