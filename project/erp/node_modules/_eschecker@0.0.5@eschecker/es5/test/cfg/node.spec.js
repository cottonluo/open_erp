"use strict";

var _chai = require("chai");

var _node = require("../../lib/cfg/node");

var _node2 = _interopRequireDefault(_node);

var _edge = require("../../lib/cfg/edge");

var _edge2 = _interopRequireDefault(_edge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("Node", () => {
	describe("constructor", () => {
		it("has an empty successor and predecessor set by default", () => {
			// act
			const node = new _node2.default("x");

			// assert
			(0, _chai.expect)(node.predecessors.size).to.equal(0);
			(0, _chai.expect)(node.successors.size).to.equal(0);
		});

		it("stores the value", () => {
			// act
			const node = new _node2.default("x");

			// assert
			(0, _chai.expect)(node).to.have.property("value").that.is.equal("x");
		});
	});

	describe("isSuccessorOf", () => {
		let nodeA, nodeB;
		beforeEach(() => {
			nodeA = new _node2.default("A");
			nodeB = new _node2.default("B");
		});

		it("returns false when nodes have no common edge", () => {
			(0, _chai.expect)(nodeA.isSuccessorOf(nodeB)).to.be.false;
		});

		it("returns true when the graph node is a successor and the Branch type matches", () => {
			// arrange
			nodeA.successors.add(new _edge2.default(nodeA, "T", nodeB));

			// act, assert
			(0, _chai.expect)(nodeB.isSuccessorOf(nodeA, "T")).to.be.true;
		});

		it("returns false when the graph node is a successor but the branch type doesn't match", () => {
			// arrange
			nodeA.successors.add(new _edge2.default(nodeA, "T", nodeB));

			// act, assert
			(0, _chai.expect)(nodeB.isSuccessorOf(nodeA, "F")).to.be.false;
		});

		it("returns true for predecessor when the function is called without a branch type", () => {
			// arrange
			nodeA.successors.add(new _edge2.default(nodeA, "F", nodeB));

			// act, assert
			(0, _chai.expect)(nodeB.isSuccessorOf(nodeA)).to.be.true;
		});

		it("returns false when the nodes have an edge but in the opposite direction", () => {
			// arrange
			nodeB.successors.add(new _edge2.default(nodeB, "F", nodeA));

			// act, assert
			(0, _chai.expect)(nodeB.isSuccessorOf(nodeA)).to.be.false;
		});
	});
});
//# sourceMappingURL=node.spec.js.map
