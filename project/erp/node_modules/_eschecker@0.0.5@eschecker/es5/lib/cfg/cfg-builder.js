"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CfgBuilder = undefined;

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _lodash = require("lodash");

var _ = _interopRequireWildcard(_lodash);

var _successor = require("./successor");

var _successor2 = _interopRequireDefault(_successor);

var _fallthrough = require("./fallthrough");

var _fallthrough2 = _interopRequireDefault(_fallthrough);

var _controlFlowGraph = require("./control-flow-graph");

var _controlFlowGraph2 = _interopRequireDefault(_controlFlowGraph);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fallThrough(to) {
	const p = (0, _fallthrough2.default)(to);
	return p ? p.node : null;
}

function successor(from) {
	const p = (0, _successor2.default)(from);
	return p ? p.node : null;
}

/**
 * Determines if the passed in path (always a statement) might throws an exception at runtime.
 * The method does only check all expressions that are a direct child of this statement.
 * It does not check if the path contains any child statements that might throw an exception.
 * @param path {NodePath} the node path to verify
 * @returns {boolean} returns true if the evaluation of this statement might throw an exception.
 */
function mayThrowException(path) {
	(0, _assert2.default)(path.isStatement(), `The path with a node '${ path.node.type }' needs to be a statement.`);

	// first check if the statement itself may throw an exception
	if (path.isThrowStatement()) {
		return true;
	}
	// declarations can never throw
	if (path.isFunction()) {
		return false;
	}

	let expressionThrows = false;

	// check if the path contains any direct sub expression that might throw;
	path.traverse({
		enter(expressionPath) {
			// if it is a statement, then it will have an exception connection itself, we do not need to consider this here.
			if (expressionPath.isStatement()) {
				expressionPath.stop();
			}

			// TODO #18 Assert May throw list is complete
			switch (expressionPath.node.type) {
				case "CallExpression":
				case "NewExpression":
				case "MemberExpression":
				case "TaggedTemplateExpression":
				case "AssignmentExpression":
				case "UpdateExpression":
				case "UnaryExpression":
					expressionThrows = true;
					expressionPath.stop();
			}
		}
	});

	return expressionThrows;
}

/**
 * Returns the next case statement that follows the passed in case statement while skipping default statements
 * until the default case is the last case. Case statements are evaluated in order, but the default statement is always evaluated last.
 * So it's required to skip any default cases as long as the switch statement has any more case statements.
 * @param {!NodePath} path the case statement path for which the following case statement should be determined
 * @returns {?NodePath} the node path of the following case or default case or null if the case is the last
 */
function getNextCase(path) {
	let nextCase = path.getSibling(path.key + 1);

	while (nextCase.node && !nextCase.node.test) {
		nextCase = nextCase.getSibling(nextCase.key + 1);
	}

	if (nextCase.node) {
		return nextCase.node;
	}

	// ok no more cases, search default case
	let defaultCase = path.getSibling(0);
	while (defaultCase.node && defaultCase.node.test) {
		defaultCase = defaultCase.getSibling(defaultCase.key + 1);
	}

	return defaultCase.node ? defaultCase.node : null;
}

/**
 * Returns the first consequent statement for the passed in case path.
 * @param {NodePath} casePath the case path for which the consequent statement should be determined.
 * @returns {?NodePath} If the case statement has no consequent statements
 * itself then the consequent statements of a following case are returned. If the case has neither a consequent statement
 * itself nor any following consequent statements, then null is returned
 */
function getConsequentForCase(casePath) {
	while (casePath.node && casePath.node.consequent.length === 0) {
		casePath = casePath.getSibling(casePath.key + 1);
	}

	if (casePath.node && casePath.node.consequent.length > 0) {
		return casePath.get("consequent")[0];
	}

	return null;
}

/**
 * AST Visitor that creates the control flow graph and assigns it to the root ast node.
 * The control flow graph is build on a statement basis, so it will only contain statements as nodes and not expressions.
 */
class CfgBuilder {
	/**
  * Creates a new analyzer that creates the cfg for the given ast
  * @param {AstNode} ast the ast entry node
     */
	constructor(ast) {
		this.ast = ast;
		this.ast.cfg = new _controlFlowGraph2.default(ast);
		this.exceptionHandlers = [];
	}

	get cfg() {
		return this.ast.cfg;
	}

	enterProgram(path) {
		this.exceptionHandlers.push(path);
	}

	//------------------------------------------
	// Statements
	//------------------------------------------
	enterEmptyStatement() {
		// skip
	}

	enterBlockStatement(path) {
		const blockGraphNode = this.cfg.createNode(path.node);

		const statements = path.get("body");
		const firstStatement = _.first(statements);

		if (firstStatement) {
			this.cfg.connectIfNotFound(blockGraphNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, fallThrough(firstStatement));
		} else {
			this.cfg.connectIfNotFound(blockGraphNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, successor(path));
		}
	}

	enterExpressionStatement(path) {
		this._connectWithSuccessor(path);
	}

	enterIfStatement(path) {
		const ifGraphNode = this.cfg.createNode(path.node);
		this.cfg.connectIfNotFound(ifGraphNode, _controlFlowGraph.BRANCHES.TRUE, fallThrough(path.get("consequent")));

		if (path.node.alternate) {
			this.cfg.connectIfNotFound(ifGraphNode, _controlFlowGraph.BRANCHES.FALSE, fallThrough(path.get("alternate")));
		} else {
			this.cfg.connectIfNotFound(ifGraphNode, _controlFlowGraph.BRANCHES.FALSE, successor(path));
		}

		this._connectWithExceptionHandler(path);
	}

	/**
  * A labeled statement can safely be ignored. The body is always a statement that than is
  * handled. The label statement itself has no effect on the control flow
     */
	enterLabeledStatement() {}

	enterBreakStatement(path) {
		this._connectWithSuccessor(path);
	}

	enterContinueStatement(path) {
		this._connectWithSuccessor(path);
	}

	enterSwitchStatement(path) {
		const switchNode = this.cfg.createNode(path.node);

		if (path.node.cases.length > 0) {
			// the default case is the last case to test even when it isn't the 'case' statement in the code
			if (!path.node.cases[0].test && path.node.cases.length > 1) {
				this.cfg.connectIfNotFound(switchNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, fallThrough(path.get("cases")[1]));
			} else {
				this.cfg.connectIfNotFound(switchNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, fallThrough(path.get("cases")[0]));
			}
		} else {
			this.cfg.connectIfNotFound(switchNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, successor(path));
		}
		this._connectWithExceptionHandler(path);
	}

	enterReturnStatement(path) {
		// TODO #18 support continue, break and return statement inside of a try finally
		const tryCatch = path.findParent(parent => parent.isTryStatement());
		(0, _assert2.default)(!tryCatch || !tryCatch.node.finalizer, "Return statements inside of a try statement with a finalizer are not supported");

		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);
		this._connectWithExceptionHandler(path);
	}

	enterTryStatement(path) {
		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, path.node.block);
		if (path.node.handler) {
			this.exceptionHandlers.push(path.get("handler"));
		}
	}

	enterThrowStatement(path) {
		const lastExceptionHandler = _.last(this.exceptionHandlers);
		const successor = lastExceptionHandler.isCatchClause() ? lastExceptionHandler.node : null;
		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, successor);
	}

	enterWhileStatement(path) {
		this._loop(path);
	}

	enterDoWhileStatement(path) {
		this._loop(path);
	}

	enterForStatement(path) {
		// for (init; condition; update) { body };
		const forGraphNode = this.cfg.createNode(path.node);

		if (path.node.init) {
			this.cfg.connectIfNotFound(path.node.init, _controlFlowGraph.BRANCHES.UNCONDITIONAL, forGraphNode);
		}

		if (path.node.test) {
			this.cfg.connectIfNotFound(forGraphNode, _controlFlowGraph.BRANCHES.FALSE, successor(path));
		}

		if (path.node.update) {
			this.cfg.connectIfNotFound(path.node.update, _controlFlowGraph.BRANCHES.UNCONDITIONAL, forGraphNode);
		}

		this.cfg.connectIfNotFound(forGraphNode, _controlFlowGraph.BRANCHES.TRUE, fallThrough(path.get("body")));
		this._connectWithExceptionHandler(path);
	}

	enterForInStatement(path) {
		this._loop(path);
	}

	enterForOfStatement(path) {
		this._loop(path);
	}

	//------------------------------------------
	// Declarations
	//------------------------------------------

	enterVariableDeclaration(path) {
		// variable declarations might be a statement or part of another statement like for in or for loop
		// in this case we do not want to create a separate node as the declaration is handled in the loop
		if (path.isStatement()) {
			this._connectWithSuccessor(path);
		}
	}

	enterFunctionDeclaration(path) {
		this.exceptionHandlers.push(path);
		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, successor(path));
	}

	exitFunctionDeclaration(path) {
		(0, _assert2.default)(_.last(this.exceptionHandlers) === path);
		this.exceptionHandlers.pop();
	}

	enterFunctionExpression(path) {
		this.exceptionHandlers.push(path);
	}

	exitFunctionExpression(path) {
		this.exitFunctionDeclaration(path);
	}

	enterArrowFunctionExpression(path) {
		this.exceptionHandlers.push(path);
		this.cfg.connectIfNotFound(path.node.body, _controlFlowGraph.BRANCHES.UNCONDITIONAL, null);
	}

	exitArrowFunctionExpression(path) {
		this.exitFunctionDeclaration(path);
	}

	//------------------------------------------
	// Clauses
	//------------------------------------------

	enterCatchClause(path) {
		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, path.node.body);

		// as soon as we are inside of the catch block, another exception handler is responsible for any occurring exceptions
		(0, _assert2.default)(_.last(this.exceptionHandlers) === path);
		this.exceptionHandlers.pop();
	}

	enterSwitchCase(path) {
		const caseNode = this.cfg.createNode(path.node);
		const consequent = getConsequentForCase(path);
		let trueBranch = consequent ? fallThrough(consequent) : successor(path.parentPath);

		// case x:
		if (path.node.test) {
			this.cfg.connectIfNotFound(caseNode, _controlFlowGraph.BRANCHES.TRUE, trueBranch);

			const nextCase = getNextCase(path);
			if (nextCase) {
				this.cfg.connectIfNotFound(caseNode, _controlFlowGraph.BRANCHES.FALSE, nextCase);
			} else {
				this.cfg.connectIfNotFound(caseNode, _controlFlowGraph.BRANCHES.FALSE, successor(path.parentPath));
			}
		} else {
			// default
			this.cfg.connectIfNotFound(caseNode, _controlFlowGraph.BRANCHES.UNCONDITIONAL, trueBranch);
		}
	}

	//------------------------------------------
	// Non ES Tree Functions
	//------------------------------------------

	defaultHandler(path) {
		(0, _assert2.default)(!path.isStatement(), `Unhandled statement of type ${ path.node.type }.`);
	}

	_connectWithSuccessor(path) {
		this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.UNCONDITIONAL, successor(path));
		this._connectWithExceptionHandler(path);
	}

	_connectWithExceptionHandler(path) {
		if (mayThrowException(path) && _.last(this.exceptionHandlers).isCatchClause()) {
			this.cfg.connectIfNotFound(path.node, _controlFlowGraph.BRANCHES.EXCEPTION, _.last(this.exceptionHandlers).node);
		}
	}

	_loop(path) {
		const loopNode = this.cfg.createNode(path.node);

		this.cfg.connectIfNotFound(loopNode, _controlFlowGraph.BRANCHES.TRUE, fallThrough(path.get("body")));
		this.cfg.connectIfNotFound(loopNode, _controlFlowGraph.BRANCHES.FALSE, successor(path));
		this._connectWithExceptionHandler(path);
	}
}

exports.CfgBuilder = CfgBuilder;
exports.default = CfgBuilder;
//# sourceMappingURL=cfg-builder.js.map
