"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.AssignmentExpressionRefinementRule = undefined;

var _typeInferenceError = require("../type-inference-error");

var _binaryOperators = require("./binary-operators");

var _binaryOperators2 = _interopRequireDefault(_binaryOperators);

var _types = require("../../semantic-model/types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Refinement rule for assignment expressions
 * @implements {RefinementRule}
 */
class AssignmentExpressionRefinementRule {

	canRefine(node) {
		return node.type === "AssignmentExpression";
	}

	refine(node, context) {
		let rightType;

		if (node.operator === "=") {
			rightType = context.infer(node.right);
		} else {
			rightType = this._getTypeFromBinaryOperator(node, context);
		}

		this._setTypeForAssignee(node.left, rightType.fresh(), context);

		return rightType;
	}

	_getTypeFromBinaryOperator(node, context) {
		const binaryOperator = node.operator.replace("=", "");

		if (binaryOperator in _binaryOperators2.default) {
			const leftType = context.infer(node.left);
			const rightType = context.infer(node.right);

			const operator = _binaryOperators2.default[binaryOperator];
			return operator.refine(leftType, rightType, (t1, t2) => context.unify(t1, t2, node));
		}

		throw new _typeInferenceError.TypeInferenceError(`The assignment operator ${ node.operator } is not supported`, node);
	}

	_setTypeForAssignee(assigneeNode, rightHandSideType, context) {
		if (assigneeNode.type === "MemberExpression") {
			this._setPropertyType(assigneeNode, rightHandSideType, context);
		} else {
			const symbol = context.getSymbol(assigneeNode);
			context.setType(symbol, rightHandSideType);
		}
	}

	_setPropertyType(assigneeNode, propertyType, context) {
		const objectType = context.getObjectType(assigneeNode);
		const propertySymbol = context.getSymbol(assigneeNode.property);

		if (objectType instanceof _types.AnyType) {
			return;
		}

		let updatedObjectType;
		if (objectType.hasProperty(propertySymbol)) {
			updatedObjectType = objectType.setType(propertySymbol, propertyType);
		} else {
			updatedObjectType = objectType.addProperty(propertySymbol, propertyType);
		}

		context.substitute(objectType, updatedObjectType);
	}
}

exports.AssignmentExpressionRefinementRule = AssignmentExpressionRefinementRule;
exports.default = AssignmentExpressionRefinementRule;
//# sourceMappingURL=assignment-expression-refinement-rule.js.map
