"use strict";

var _chai = require("chai");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

describe("StringType", function () {
	describe("getType", function () {
		it("returns the type for built in functions", function () {
			// arrange
			const sType = _types.StringType.create();

			// act
			const trim = sType.getType(new _symbol.Symbol("trim"));

			// assert
			(0, _chai.expect)(trim).to.be.instanceOf(_types.FunctionType);
			(0, _chai.expect)(trim.thisType).to.be.instanceOf(_types.StringType);
			(0, _chai.expect)(trim.params).to.be.empty;
			(0, _chai.expect)(trim.returnType).to.be.instanceOf(_types.StringType);
		});

		it("returns undefined for not existing properties", function () {
			// arrange
			const sType = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(sType.getType(new _symbol.Symbol("trim2"))).to.be.undefined;
		});
	});

	describe("hasProperty", function () {
		it("returns true for built in types", function () {
			// arrange
			const sType = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(sType.hasProperty(new _symbol.Symbol("trim"))).to.be.true;
		});

		it("returns false for not existing properties", function () {
			// arrange
			const sType = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(sType.hasProperty(new _symbol.Symbol("trim2"))).to.be.false;
		});
	});

	describe("setType", function () {
		it("throws if a property of the build in type should be changed", function () {
			// arrange
			const sType = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(() => sType.setType(new _symbol.Symbol("trim"), _types.StringType.create())).to.throw("Cannot modify properties of the built in type string");
		});
	});
});
//# sourceMappingURL=string-type.spec.js.map
