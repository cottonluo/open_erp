"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.SourceFile = undefined;

var _babylon = require("babylon");

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelCodeFrame = require("babel-code-frame");

var _babelCodeFrame2 = _interopRequireDefault(_babelCodeFrame);

var _parentInitializerVisitor = require("./parent-initializer-visitor");

var _parentInitializerVisitor2 = _interopRequireDefault(_parentInitializerVisitor);

var _scope = require("./scope");

var _scope2 = _interopRequireDefault(_scope);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {Object} AstNode Babylon AST-Node
 */

class SourceFile {
	constructor(path, text, globalScope) {
		/**
   * The path of the file realtive to the project root (can be used to resolve the file)
   * @type {String}
   */
		this.path = path;

		/**
   * The content of the file as text
   * @type {String}
   */
		this.text = text;

		/**
   * The ast representation of the ast after parse has been called
   * @type {Node}
         */
		this.ast = {};

		/**
   * The scope that is valid for this file. A source file has always it's own
   * scope that is a direct child of the global scope.
   * @type {Scope}
         */
		this.scope = new _scope2.default(globalScope);
	}

	/**
  * Parses the source code of this file to an ast representation and assigns the ast to {@link SourceFile.ast}.
  */
	parse() {
		this.ast = (0, _babylon.parse)(this.text, {
			sourceType: "module", // default: "script"
			sourceFilename: this.path
		});
	}

	/**
  * Executes the given analysers on the ast of this source file
  * @param analysers the analysers to execute
     */
	analyse(analysers) {
		const astVisitors = [];
		const states = [];

		for (const analyser of [_parentInitializerVisitor2.default].concat(analysers)) {
			astVisitors.push(analyser);
		}

		const mergedVisitor = _babelTraverse.visitors.merge(astVisitors, states);
		(0, _babelTraverse2.default)(this.ast, mergedVisitor);
	}

	/**
  * Creates a code frame that marks the start position of the passed in node
  * @param {AstNode} node the ast node for which the code frame should be shown
  * @returns {string} the code frame for this node
     */
	codeFrame(node) {
		return (0, _babelCodeFrame2.default)(this.text, node.loc.start.line, node.loc.start.column, { highlightCode: true });
	}
}

exports.SourceFile = SourceFile;
exports.default = SourceFile;
//# sourceMappingURL=source-file.js.map
