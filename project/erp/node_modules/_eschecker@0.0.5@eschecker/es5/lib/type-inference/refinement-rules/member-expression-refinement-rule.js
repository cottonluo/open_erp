"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MemberExpressionRefinementRule = undefined;

var _types = require("../../semantic-model/types");

/**
 * Refinement rule for a member expressions.
 *
 * The refinement rule uses the object symbol to resolve the type of a member.
 * If the member has not yet a type variable associated with it in the type environment,
 * then a new type variable is created and associated with the symbol of the member.
 *
 * The implementation does change the structure of the record type at all, as it does not know if it is a
 * read or write access. Adding new Members to record types is performed in the assignment expression
 * refinement rule.
 *
 * @implements {RefinementRule}
 */
class MemberExpressionRefinementRule {
  canRefine(node) {
    return node.type === "MemberExpression";
  }

  refine(node, context) {
    const propertySymbol = context.getSymbol(node.property);
    const objectType = context.getObjectType(node);

    if (objectType instanceof _types.AnyType) {
      return _types.AnyType.create();
    }

    // Accessing a property that does not exist is fine, e.g. if(x.address), the value is just void
    return objectType.getType(propertySymbol) || _types.VoidType.create();
  }
}

exports.MemberExpressionRefinementRule = MemberExpressionRefinementRule;
exports.default = MemberExpressionRefinementRule;
//# sourceMappingURL=member-expression-refinement-rule.js.map
