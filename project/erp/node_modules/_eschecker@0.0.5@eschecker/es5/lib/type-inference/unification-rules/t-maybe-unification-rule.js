"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.TMaybeUnificationRule = undefined;

var _index = require("../../semantic-model/types/index");

/**
 * Unification rule that unifies an arbitrary type T with Maybe<T>, which results in the Type Maybe<T>.
 *
 * @implements {BaseTypeUnificationRule}
 */
class TMaybeUnificationRule {
	canUnify(t1, t2) {
		var _extractMaybeAndOther = this._extractMaybeAndOther(t1, t2);

		const maybe = _extractMaybeAndOther.maybe;
		const other = _extractMaybeAndOther.other;


		return !!maybe && !(other instanceof _index.NullType || other instanceof _index.AnyType || other instanceof _index.VoidType || other instanceof _index.MaybeType);
	}

	unify(t1, t2, unificator) {
		var _extractMaybeAndOther2 = this._extractMaybeAndOther(t1, t2);

		const maybe = _extractMaybeAndOther2.maybe;
		const other = _extractMaybeAndOther2.other;

		if (other.equals(maybe.of)) {
			return maybe;
		}

		const ofType = unificator.unify(other, maybe.of);
		return _index.MaybeType.of(ofType);
	}

	_extractMaybeAndOther(t1, t2) {
		const maybe = t1 instanceof _index.MaybeType ? t1 : t2 instanceof _index.MaybeType ? t2 : null;
		return { maybe, other: maybe === t1 ? t2 : t1 };
	}
}

exports.TMaybeUnificationRule = TMaybeUnificationRule;
exports.default = TMaybeUnificationRule;
//# sourceMappingURL=t-maybe-unification-rule.js.map
