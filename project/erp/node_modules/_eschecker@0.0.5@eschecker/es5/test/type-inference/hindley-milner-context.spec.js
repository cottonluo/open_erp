"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _program = require("../../lib/semantic-model/program");

var _symbol = require("../../lib/semantic-model/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _hindleyMilnerContext = require("../../lib/type-inference/hindley-milner-context");

var _types = require("../../lib/semantic-model/types");

var _typeInferenceContext = require("../../lib/type-inference/type-inference-context");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("HindleyMilnerContext", function () {
	let typeInferenceAnalysis, program, typeInferenceContext, context;

	beforeEach(function () {
		program = new _program.Program();
		typeInferenceAnalysis = { infer: _sinon2.default.stub(), analyse: _sinon2.default.stub(), unify: _sinon2.default.stub() };
		typeInferenceContext = new _typeInferenceContext.TypeInferenceContext(program);
		context = new _hindleyMilnerContext.HindleyMilnerContext(typeInferenceAnalysis, typeInferenceContext);
	});

	describe("typeEnvironment", function () {
		it("returns the type environment from the type inference context", function () {
			(0, _chai.expect)(context.typeEnvironment).to.equal(typeInferenceContext.typeEnvironment);
		});

		it("sets the type environment of the type inference context", function () {
			// arrange
			const env1 = new _typeEnvironment.TypeEnvironment();

			// act
			typeInferenceContext.typeEnvironment = env1;

			// assert
			(0, _chai.expect)(typeInferenceContext.typeEnvironment).to.equal(env1);
		});
	});

	describe("infer", function () {
		it("calls the infer function of the type inference analysis", function () {
			// arrange
			const node = {};
			const type = _types.NumberType.create();

			typeInferenceAnalysis.infer.returns(type);

			// act
			const inferred = context.infer(node);

			// assert
			_sinon2.default.assert.calledWith(typeInferenceAnalysis.infer, node, context);
			(0, _chai.expect)(inferred).to.equal(type);
		});
	});

	describe("unify", function () {
		it("calls the unify function of the type inference analysis", function () {
			// arrange
			const node = {};
			const type1 = _types.NumberType.create();
			const type2 = _types.NumberType.create();

			typeInferenceAnalysis.unify.returns(type1);

			// act
			const unified = context.unify(type1, type2, node);

			// assert
			_sinon2.default.assert.calledWith(typeInferenceAnalysis.unify, type1, type2, node, context);
			(0, _chai.expect)(unified).to.equal(type1);
		});
	});

	describe("analyse", function () {
		it("calls the analyse function of the type inference analysis", function () {
			// arrange
			const node = {};

			typeInferenceAnalysis.analyse.returns(new Map([[null, context.typeEnvironment]]));

			// act
			context.analyse(node);

			// assert
			_sinon2.default.assert.calledWith(typeInferenceAnalysis.analyse, node, context.typeEnvironment);
		});

		it("updates the type environment to the type environment of the exit node", function () {
			// arrange
			const node = {};
			const exitNodeTypeEnv = new _typeEnvironment.TypeEnvironment();

			typeInferenceAnalysis.analyse.returns(new Map([[null, exitNodeTypeEnv]]));

			// act
			context.analyse(node);

			// assert
			(0, _chai.expect)(context.typeEnvironment).to.equal(exitNodeTypeEnv);
		});
	});

	describe("getType", function () {
		it("returns the type from the type inference context", function () {
			// arrange
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.Variable);
			const type = _types.NumberType.create();
			typeInferenceContext.setType(symbol, type);

			// act, assert
			(0, _chai.expect)(context.getType(symbol)).to.equal(type);
		});
	});

	describe("setType", function () {
		it("sets the type in the type inference context", function () {
			// arrange
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.Variable);
			const type = _types.NumberType.create();

			// act
			context.setType(symbol, type);

			// assert
			(0, _chai.expect)(typeInferenceContext.getType(symbol)).to.equal(type);
		});
	});

	describe("substitute", function () {
		it("calls the substitute function on the type inference context", function () {
			// arrange
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.Variable);
			const type = _types.NumberType.create();
			const newType = _types.StringType.create();

			context.setType(symbol, type);
			_sinon2.default.spy(typeInferenceContext, "substitute");

			// act
			context.substitute(type, newType);

			// assert
			(0, _chai.expect)(typeInferenceContext.getType(symbol)).to.equal(newType);
			_sinon2.default.assert.calledWith(typeInferenceContext.substitute, type, newType);
		});
	});

	describe("getObjectType", function () {
		it("returns the infered type for the object node", function () {
			// arrange
			const objectNode = t.identifier("person");
			const nameNode = t.memberExpression(objectNode, t.identifier("name"));

			const person = new _symbol2.default("person", _symbol.SymbolFlags.Variable);
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Property);

			program.symbolTable.setSymbol(objectNode, person);
			program.symbolTable.setSymbol(nameNode.property, name);

			const personType = new _types.RecordType();
			context.setType(person, personType);

			typeInferenceAnalysis.infer.withArgs(objectNode).returns(personType);

			// act
			const objectType = context.getObjectType(nameNode);

			// assert
			(0, _chai.expect)(objectType).to.equal(personType);
		});

		it("fails if the object type cannot be unified with the record type", function () {
			// arrange
			const personNode = t.identifier("person");
			const nameNode = t.memberExpression(personNode, t.identifier("name"));

			const person = new _symbol2.default("person", _symbol.SymbolFlags.Variable);
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Property);

			program.symbolTable.setSymbol(personNode, person);
			program.symbolTable.setSymbol(nameNode.property, name);

			const personType = _types.NumberType.create();
			context.setType(person, personType);
			typeInferenceAnalysis.infer.withArgs(personNode).returns(personType);

			// act
			(0, _chai.expect)(() => context.getObjectType(nameNode)).to.throw("Type inference failure: Type number is not a record type and cannot be converted to a record type, cannot be used as object.");
		});

		it("fails if the object type is null", function () {
			// arrange
			const personNode = t.identifier("person");
			const nameNode = t.memberExpression(personNode, t.identifier("name"));

			const person = new _symbol2.default("person", _symbol.SymbolFlags.Variable);
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Property);

			program.symbolTable.setSymbol(personNode, person);
			program.symbolTable.setSymbol(nameNode.property, name);

			const personType = _types.NullType.create();
			context.setType(person, personType);
			typeInferenceAnalysis.infer.withArgs(personNode).returns(personType);

			typeInferenceAnalysis.unify.returns(_types.MaybeType.of(new _types.RecordType()));

			// act
			(0, _chai.expect)(() => context.getObjectType(nameNode)).to.throw("Type inference failure: Potential null pointer when accessing property name on null or not initialized object of type null.");
		});

		it("fails if the object type is undefined", function () {
			// arrange
			const personNode = t.identifier("person");
			const nameNode = t.memberExpression(personNode, t.identifier("name"));

			const person = new _symbol2.default("person", _symbol.SymbolFlags.Variable);
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Property);

			program.symbolTable.setSymbol(personNode, person);
			program.symbolTable.setSymbol(nameNode.property, name);

			const personType = _types.VoidType.create();
			context.setType(person, personType);
			typeInferenceAnalysis.infer.withArgs(personNode).returns(personType);

			typeInferenceAnalysis.unify.returns(new _types.RecordType());

			// act
			(0, _chai.expect)(() => context.getObjectType(nameNode)).to.throw("Type inference failure: Potential null pointer when accessing property name on null or not initialized object of type undefined.");
		});

		it("returns any type if the type of the parent object is any", function () {
			// arrange
			const objectNode = t.identifier("person");
			const nameNode = t.memberExpression(objectNode, t.identifier("name"));

			const person = new _symbol2.default("person", _symbol.SymbolFlags.Variable);
			const name = new _symbol2.default("name", _symbol.SymbolFlags.Property);

			program.symbolTable.setSymbol(objectNode, person);
			program.symbolTable.setSymbol(nameNode.property, name);

			const personType = _types.AnyType.create();
			context.setType(person, personType);
			typeInferenceAnalysis.infer.withArgs(objectNode).returns(personType);

			// act
			const objectType = context.getObjectType(nameNode);

			// assert
			(0, _chai.expect)(objectType).to.be.instanceOf(_types.AnyType);
		});
	});

	describe("getSymbol", function () {
		it("resolves the symbol using the inference context", function () {
			// arrange
			const node = {};
			const symbol = new _symbol2.default("x", _symbol.SymbolFlags.Variable);

			_sinon2.default.stub(typeInferenceContext, "getSymbol").returns(symbol);

			// act
			const resolvedSymbol = context.getSymbol(node);

			// assert
			_sinon2.default.assert.calledWith(typeInferenceContext.getSymbol, node);
			(0, _chai.expect)(resolvedSymbol).to.equal(symbol);
		});
	});

	describe("getCfg", function () {
		it("resolves the cfg by using the inference context", function () {
			const node = {};
			_sinon2.default.stub(typeInferenceContext, "getCfg");

			// act
			context.getCfg(node);

			// assert
			_sinon2.default.assert.calledWith(typeInferenceContext.getCfg, node);
		});
	});

	describe("fresh", function () {
		it("returns a new object for the same type inference analysis but with a new type inference context instance", function () {
			// act
			const fresh = context.fresh();

			// assert
			(0, _chai.expect)(fresh).not.to.equal(context);
			(0, _chai.expect)(fresh._typeInferenceAnalysis).to.equal(context._typeInferenceAnalysis);
			(0, _chai.expect)(fresh._typeInferenceContext).not.to.equal(context._typeInferenceContext);
		});
	});

	describe("replaceTypes", function () {

		it("sets the type environment to the type environment with the replaced types", function () {
			// arrange
			const env1 = new _typeEnvironment.TypeEnvironment();
			const env2 = new _typeEnvironment.TypeEnvironment();
			const result = new _typeEnvironment.TypeEnvironment();

			const name = new _symbol2.default("name", _symbol.SymbolFlags.Variable);
			_sinon2.default.stub(env1, "replaceTypes").returns(result);
			context.typeEnvironment = env1;

			const otherContext = context.fresh();
			otherContext.typeEnvironment = env2;

			// act
			context.replaceTypes(otherContext, [name]);

			// assert
			(0, _chai.expect)(context.typeEnvironment).to.equal(result);
			_sinon2.default.assert.calledWith(env1.replaceTypes, env2, [name]);
		});
	});
});
//# sourceMappingURL=hindley-milner-context.spec.js.map
