"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _hindleyMilnerDataFlowAnalysis = require("../../lib/type-inference/hindley-milner-data-flow-analysis");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _program = require("../../lib/semantic-model/program");

var _typeInferenceContext = require("../../lib/type-inference/type-inference-context");

var _hindleyMilnerContext = require("../../lib/type-inference/hindley-milner-context");

var _symbol = require("../../lib/semantic-model/symbol");

var _type = require("../../lib/semantic-model/types/type");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("HindleyMilnerDataFlowAnalysis", function () {
	let analysis, typeInferenceAnalysis, program;

	beforeEach(function () {
		program = new _program.Program();
		typeInferenceAnalysis = { createHindleyMilnerContext: _sinon2.default.stub(), infer: _sinon2.default.stub() };
		analysis = new _hindleyMilnerDataFlowAnalysis.HindleyMilnerDataFlowAnalysis(typeInferenceAnalysis);
	});

	describe("createEmptyLattice", function () {
		it("returns the start type environment from the constructor", function () {
			// arrange
			const typeEnvironment = new _typeEnvironment.TypeEnvironment();
			analysis = new _hindleyMilnerDataFlowAnalysis.HindleyMilnerDataFlowAnalysis(typeInferenceAnalysis, typeEnvironment);

			// act, assert
			(0, _chai.expect)(analysis.createEmptyLattice()).to.be.equal(typeEnvironment);
		});
	});

	describe("transfer", function () {
		it("returns the in type environment for the exit node", function () {
			// arrange
			const inTypeEnvironment = new _typeEnvironment.TypeEnvironment();

			// act, assert
			(0, _chai.expect)(analysis.transfer(null, inTypeEnvironment)).to.equal(inTypeEnvironment);
		});

		it("infers the types for the node by calling the infer function on a newly created hindley milner context", function () {
			// arrange
			const inTypeEnvironment = new _typeEnvironment.TypeEnvironment();
			const node = t.identifier("x");
			const context = new _hindleyMilnerContext.HindleyMilnerContext(typeInferenceAnalysis, new _typeInferenceContext.TypeInferenceContext(program, inTypeEnvironment));

			typeInferenceAnalysis.createHindleyMilnerContext.returns(context);
			_sinon2.default.stub(context, "infer");

			// act
			analysis.transfer(node, inTypeEnvironment);

			// assert
			_sinon2.default.assert.calledWith(context.infer, node);
		});
	});

	describe("areStatesEqual", function () {
		it("is true if the type environment are the same", function () {
			// arrange
			const typeEnv = new _typeEnvironment.TypeEnvironment();

			// act, assert
			(0, _chai.expect)(analysis.areStatesEqual(typeEnv, typeEnv)).to.be.true;
		});

		it("is true if the type environment are not the same instances but have the same mappings", function () {
			// arrange
			const typeEnv = new _typeEnvironment.TypeEnvironment();
			const typeEnv2 = new _typeEnvironment.TypeEnvironment();

			// act, assert
			(0, _chai.expect)(analysis.areStatesEqual(typeEnv, typeEnv2)).to.be.true;
		});

		it("is false if the type environment are not the same instances but have the same mappings", function () {
			// arrange
			const typeEnv = new _typeEnvironment.TypeEnvironment();
			const typeEnv2 = new _typeEnvironment.TypeEnvironment().setType(new _symbol.Symbol("x", _symbol.SymbolFlags.Variable), new _type.Type("string"));

			// act, assert
			(0, _chai.expect)(analysis.areStatesEqual(typeEnv, typeEnv2)).to.be.false;
		});
	});
});
//# sourceMappingURL=hindley-milner-data-flow-analysis.spec.js.map
