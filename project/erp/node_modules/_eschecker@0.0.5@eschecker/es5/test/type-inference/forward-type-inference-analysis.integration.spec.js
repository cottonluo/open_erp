"use strict";

var _chai = require("chai");

var _symbol = require("../../lib/semantic-model/symbol");

var _program = require("../../lib/semantic-model/program");

var _typeEnvironment = require("../../lib/type-inference/type-environment");

var _infer = require("../../lib/infer");

var _types = require("../../lib/semantic-model/types");

describe("ForwardTypeInferenceAnalysis Integration Tests", function () {

	it("can analyse an empty program", function () {
		(0, _chai.expect)(() => inferTypes("// alert('Hello world!');")).not.to.throw();
	});

	it("infers the types for declared variables correctly", function () {
		// act

		var _inferTypes = inferTypes(`
			let age = 10;
			let born = true;
			let name = "test";
			let dateOfDeath = null;
			let hero;
		`);

		const typeEnvironment = _inferTypes.typeEnvironment;
		const scope = _inferTypes.scope;

		// assert

		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("age"))).to.be.instanceOf(_types.NumberType);
		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("born"))).to.be.instanceOf(_types.BooleanType);
		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("name"))).to.be.instanceOf(_types.StringType);
		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("dateOfDeath"))).to.be.instanceOf(_types.NullType);
		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("hero"))).to.be.instanceOf(_types.VoidType);
	});

	it("changes the type of a variable to number when it is initialized with null but later assigned a number", function () {
		// act

		var _inferTypes2 = inferTypes(`
		let age = null;
		age = 10;
		`);

		const typeEnvironment = _inferTypes2.typeEnvironment;
		const scope = _inferTypes2.scope;

		// assert

		(0, _chai.expect)(typeEnvironment.getType(scope.resolveSymbol("age"))).to.be.instanceOf(_types.NumberType);
	});

	it("infers the type from the result of a function call", function () {
		// act

		var _inferTypes3 = inferTypes(`
		function test(x) {
			return x * 2;
		}
		
		const l = test(10);
		`);

		const typeEnvironment = _inferTypes3.typeEnvironment;
		const ast = _inferTypes3.ast;

		// assert

		const functionNode = ast.program.body[0];
		const functionScope = functionNode.scope;

		(0, _chai.expect)(typeEnvironment.getType(functionScope.resolveSymbol("l"))).to.be.instanceOf(_types.NumberType);
	});

	it("changes to aliased variables are not reflected to their aliases", function () {
		// act

		var _inferTypes4 = inferTypes(`
		let p1 = { name: "Micha", age: 26};
		let person = p1;
		person.address = { street: "Nice view 23" };
		`);

		const typeEnvironment = _inferTypes4.typeEnvironment;
		const scope = _inferTypes4.scope;

		// assert

		const person = scope.resolveSymbol("person");
		const p1 = scope.resolveSymbol("p1");
		const personType = typeEnvironment.getType(person);
		const p1Type = typeEnvironment.getType(p1);

		(0, _chai.expect)(personType).to.be.instanceOf(_types.RecordType);
		(0, _chai.expect)(personType.hasProperty(p1.getMember("name"))).to.be.true;
		(0, _chai.expect)(personType.hasProperty(p1.getMember("age"))).to.be.true;
		(0, _chai.expect)(personType.hasProperty(person.getMember("address"))).to.be.true;
		(0, _chai.expect)(p1Type.hasProperty(person.getMember("address"))).to.be.false;

		const address = person.getMember("address");
		const addressType = personType.getType(address);
		(0, _chai.expect)(addressType).to.be.instanceOf(_types.RecordType);
		(0, _chai.expect)(addressType.hasProperty(address.getMember("street")));
	});

	it("throws an error if a not declared identifier is passed to a function call", function () {
		(0, _chai.expect)(() => inferTypes(`
		function toNumber(x) {
			x = 10;
			return x;
		}
		
		toNumber(x);
		`)).to.throw("Type inference failure: The symbol x is being used before it's declaration");
	});

	it("it does not refine the type for identifiers used in calculations to not reduce the accuracy of their inferred type (x=null is here the most accurate information)", function () {
		// act

		var _inferTypes5 = inferTypes(`
		const x = null;
		const y = 2 * x;
		`);

		const typeEnvironment = _inferTypes5.typeEnvironment;
		const scope = _inferTypes5.scope;

		// assert

		const x = scope.resolveSymbol("x");
		const y = scope.resolveSymbol("y");

		(0, _chai.expect)(typeEnvironment.getType(x)).to.be.instanceOf(_types.NullType);
		(0, _chai.expect)(typeEnvironment.getType(y)).to.be.instanceOf(_types.NumberType);
	});

	it("merges the type definitions from different branches", function () {
		// act

		var _inferTypes6 = inferTypes(`
			let p1 = { name: null, age: null};
			
			if (!p1.name) {
				p1.name = "Default";
			}
		`);

		const typeEnvironment = _inferTypes6.typeEnvironment;
		const scope = _inferTypes6.scope;

		// assert

		const p1 = scope.resolveSymbol("p1");
		const p1Record = typeEnvironment.getType(p1);
		(0, _chai.expect)(p1Record.getType(p1.getMember("name"))).to.be.instanceOf(_types.MaybeType).and.to.have.property("of").that.is.an.instanceOf(_types.StringType);
	});

	it("refines the types between each cfg step", function () {
		// act

		var _inferTypes7 = inferTypes(`
		let x = null;
		x = 15;
		`);

		const scope = _inferTypes7.scope;
		const ast = _inferTypes7.ast;
		const typeEnvironments = _inferTypes7.typeEnvironments;

		// assert

		const typeEnv1 = typeEnvironments.get(ast.program.body[0]);
		const typeEnv2 = typeEnvironments.get(ast.program.body[1]);
		const x = scope.resolveSymbol("x");

		(0, _chai.expect)(typeEnv1.getType(x)).to.be.instanceOf(_types.NullType);
		(0, _chai.expect)(typeEnv2.getType(x)).to.be.instanceOf(_types.NumberType);
	});

	describe("members", function () {
		it("adds added properties in a function call to the type in the callers context", function () {
			// act

			var _inferTypes8 = inferTypes(`
			function setName(x, name) {
				x.name = name;
			}
			
			let p = {};
			setName(p, "Test");
			`);

			const typeEnvironment = _inferTypes8.typeEnvironment;
			const scope = _inferTypes8.scope;


			const p = scope.resolveSymbol("p");
			const pType = typeEnvironment.getType(p);

			// assert
			(0, _chai.expect)(pType).to.be.instanceOf(_types.RecordType);
			(0, _chai.expect)(pType.getType(new _symbol.Symbol("name"))).to.be.instanceOf(_types.StringType);
		});

		it("throws if a function access members of an object that is null or not defined", function () {
			(0, _chai.expect)(() => inferTypes(`
			function getStreet(x) {
				return x.address.street;
			}
			
			getStreet({});
			`)).to.throw("Type inference failure: Potential null pointer when accessing property street on null or not initialized object of type undefined.");
		});

		it("a member is void if it is accessed before it's declaration", function () {
			// act

			var _inferTypes9 = inferTypes(`
			function getName(x) {
				return x.name;
			}
			
			let name = getName({});
			`);

			const typeEnvironment = _inferTypes9.typeEnvironment;
			const scope = _inferTypes9.scope;


			const name = scope.resolveSymbol("name");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(name)).to.be.instanceOf(_types.VoidType);
		});

		it("returns type any for computed properties", function () {
			// act

			var _inferTypes10 = inferTypes(`
			let keys = []; // e.g. Object.keys
			let o = {};
			const v = o[keys[0]];
			`);

			const typeEnvironment = _inferTypes10.typeEnvironment;
			const scope = _inferTypes10.scope;


			const v = scope.resolveSymbol("v");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(v)).to.be.instanceOf(_types.AnyType);
		});

		it("returns type any for a member access on a computed property", function () {
			// act

			var _inferTypes11 = inferTypes(`
			let keys = []; // e.g. Object.keys
			let o = {};
			const v = o[keys[i]].length;
			`);

			const typeEnvironment = _inferTypes11.typeEnvironment;
			const scope = _inferTypes11.scope;


			const v = scope.resolveSymbol("v");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(v)).to.be.instanceOf(_types.AnyType);
		});

		it("allows assignment to a computed property", function () {
			// act

			var _inferTypes12 = inferTypes(`
			let keys = ['name']; // e.g. Object.keys
			let o = {};
			o[keys[0]] = "test";
			const name = o.name;
			`);

			const typeEnvironment = _inferTypes12.typeEnvironment;
			const scope = _inferTypes12.scope;


			const name = scope.resolveSymbol("name");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(name)).to.be.instanceOf(_types.AnyType);
		});
	});

	describe("function call", function () {
		it("a built in function with optional parameters can be invoked", function () {
			// act

			var _inferTypes13 = inferTypes("const substr = 'Micha Reiser'.substring(4);");

			const scope = _inferTypes13.scope;
			const typeEnvironment = _inferTypes13.typeEnvironment;

			// assert

			const substring = scope.resolveSymbol("substr");
			(0, _chai.expect)(typeEnvironment.getType(substring)).to.be.instanceOf(_types.StringType);
		});

		it("resolves a type variable from the outer context", function () {
			// act

			var _inferTypes14 = inferTypes(`
				let x;
				
				function a() {
					x = 10;
				}
				a();
				const b = x;
			`);

			const scope = _inferTypes14.scope;
			const typeEnvironment = _inferTypes14.typeEnvironment;

			// assert

			const b = scope.resolveSymbol("b");
			(0, _chai.expect)(typeEnvironment.getType(b)).to.be.an.instanceOf(_types.NumberType);
		});

		it("does not change the type of the callers argument when the function assigns to the parameters of the function", function () {
			// act

			var _inferTypes15 = inferTypes(`
			function toNumber(x) {
				x = 10;
				return x;
			}
			
			let input = "10";
			toNumber(input);
			`);

			const typeEnvironment = _inferTypes15.typeEnvironment;
			const scope = _inferTypes15.scope;


			const ten = scope.resolveSymbol("input");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(ten)).to.be.instanceOf(_types.StringType);
		});

		it("does not update the type of the callers argument when the function reassigns the variable", function () {
			// act

			var _inferTypes16 = inferTypes(`
			function defaults(options) {
				options = { test: true };
				return options;
			}
			
			let calculationOptions = { nullAsZero: true }
			defaults(calculationOptions);
			`);

			const typeEnvironment = _inferTypes16.typeEnvironment;
			const scope = _inferTypes16.scope;


			const calculationOptions = scope.resolveSymbol("calculationOptions");

			// assert
			const type = typeEnvironment.getType(calculationOptions);
			(0, _chai.expect)(type).to.be.instanceOf(_types.ObjectType);
			(0, _chai.expect)(type.hasProperty(new _symbol.Symbol("test"))).to.be.false;
			(0, _chai.expect)(type.hasProperty(new _symbol.Symbol("nullAsZero"))).to.be.true;
		});

		it("throws if a built in function is called where the this type is not a subtype of the required this type", function () {
			(0, _chai.expect)(() => inferTypes(`
				const substr = "".substr;
				substr(3);
			`)).to.throw("Type inference failure: The function cannot be called with this of type 'undefined' whereas 'string' is required.");
		});

		it("supports functions as arguments", function () {
			// act

			var _inferTypes17 = inferTypes(`
			function id(x) {
				return x;
			}
			
			const ten = id(id)(10);
			`);

			const typeEnvironment = _inferTypes17.typeEnvironment;
			const scope = _inferTypes17.scope;


			const ten = scope.resolveSymbol("ten");

			// assert
			(0, _chai.expect)(typeEnvironment.getType(ten)).to.be.instanceOf(_types.NumberType);
		});

		it("supports closures", function () {
			var _inferTypes18 = inferTypes(`
			const result = [];
			function filter(i) {
				if (i % 2 === 0) {
					result.push(i);
				}
			}
			
			let i = 0;
			while (i < 10) {
				filter(i++);
			}
			`);

			const scope = _inferTypes18.scope;
			const typeEnvironment = _inferTypes18.typeEnvironment;

			// assert

			const result = scope.resolveSymbol("result");

			(0, _chai.expect)(typeEnvironment.getType(result)).to.be.instanceOf(_types.ArrayType).and.has.property("of").that.is.an.instanceOf(_types.NumberType);
		});

		it("can infer the type of recursive functions", function () {
			// act

			var _inferTypes19 = inferTypes(`
			function successor(x) {
				if (x === 0) {
					return 1;
				}
			
				return successor(x - 1) + 1;
			}
			let eleven = successor(10000);
			`);

			const scope = _inferTypes19.scope;
			const typeEnvironment = _inferTypes19.typeEnvironment;

			// assert

			const eleven = scope.resolveSymbol("eleven");

			(0, _chai.expect)(typeEnvironment.getType(eleven)).to.be.instanceOf(_types.NumberType);
		});

		it("can invoke built in function types", function () {
			// act

			var _inferTypes20 = inferTypes("const uppercase = 'Micha Reiser'.toUpperCase();");

			const scope = _inferTypes20.scope;
			const typeEnvironment = _inferTypes20.typeEnvironment;

			// assert

			const uppercase = scope.resolveSymbol("uppercase");
			(0, _chai.expect)(typeEnvironment.getType(uppercase)).to.be.instanceOf(_types.StringType);
		});

		it("infers the correct return type for a function that calls a function in a loop", function () {
			// act

			var _inferTypes21 = inferTypes(`
			function compute() {
				for (let i = 0; i < 10; ++i) {
					(function () { return i % 2 === 0; })();
				}
				return "done";
			}
			
			const result = compute(); 
			`);

			const scope = _inferTypes21.scope;
			const typeEnvironment = _inferTypes21.typeEnvironment;

			// assert

			const result = scope.resolveSymbol("result");
			(0, _chai.expect)(typeEnvironment.getType(result)).to.be.instanceOf(_types.StringType);
		});

		it("throws if a required argument is missing when calling a built in function", function () {
			(0, _chai.expect)(() => inferTypes("'Micha Reiser'.substring();")).to.throw("Type inference failure: The argument 1 with type \'undefined\' is not a subtype of the required parameter type \'number\'.");
		});

		it("throws if an argument of a built in function is not a subtype of the parameter type", function () {
			(0, _chai.expect)(() => inferTypes("'Micha Reiser'.substring('3');")).to.throw("Type inference failure: Unification for type \'string\' and \'number\' failed because there exists no rule that can be used to unify the given types.");
		});

		it("can invoke functions of built in objects", function () {
			(0, _chai.expect)(() => inferTypes("console.log('x');")).not.to.throw();
		});
	});

	describe("array", function () {
		it("infers the type of an array", function () {
			// act

			var _inferTypes22 = inferTypes("const numbers = [3, 4, 5, 6]");

			const scope = _inferTypes22.scope;
			const typeEnvironment = _inferTypes22.typeEnvironment;

			// assert

			const numbers = scope.resolveSymbol("numbers");
			const numbersType = typeEnvironment.getType(numbers);

			(0, _chai.expect)(numbersType).to.be.instanceOf(_types.ArrayType);
			(0, _chai.expect)(numbersType).to.have.property("of").that.is.an.instanceOf(_types.NumberType);
		});

		it("an array is of type any if the elements have no other common type", function () {
			// act

			var _inferTypes23 = inferTypes("const numbers = [3, 'four', 5, 'six']");

			const scope = _inferTypes23.scope;
			const typeEnvironment = _inferTypes23.typeEnvironment;

			// assert

			const numbers = scope.resolveSymbol("numbers");
			const numbersType = typeEnvironment.getType(numbers);

			(0, _chai.expect)(numbersType).to.be.instanceOf(_types.ArrayType);
			(0, _chai.expect)(numbersType).to.have.property("of").that.is.an.instanceOf(_types.AnyType);
		});

		it("infers the type of an array to the most common subtype", function () {
			// act

			var _inferTypes24 = inferTypes(`
			const p1 = {name: 'Test' };
			const p2 = {name: 'Test2', street: '...'};
			const p3 = {name: 'Test3', age: 12};
			const persons = [p1, p2, p3];
			`);

			const scope = _inferTypes24.scope;
			const typeEnvironment = _inferTypes24.typeEnvironment;

			// assert

			const persons = scope.resolveSymbol("persons");
			const personsType = typeEnvironment.getType(persons);

			(0, _chai.expect)(personsType).to.be.instanceOf(_types.ArrayType);
			(0, _chai.expect)(personsType).to.have.property("of").that.is.an.instanceOf(_types.ObjectType);
			(0, _chai.expect)(personsType.of.getType(new _symbol.Symbol("name"))).to.be.instanceOf(_types.StringType);
			(0, _chai.expect)(personsType.of.getType(new _symbol.Symbol("street"))).to.be.undefined;
			(0, _chai.expect)(personsType.of.getType(new _symbol.Symbol("age"))).to.be.undefined;
		});

		it("can access array elements", function () {
			// act

			var _inferTypes25 = inferTypes(`
			const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			const two = numbers[1];
			numbers[1] = 4;
			`);

			const scope = _inferTypes25.scope;
			const typeEnvironment = _inferTypes25.typeEnvironment;

			// assert

			const two = scope.resolveSymbol("two");

			(0, _chai.expect)(typeEnvironment.getType(two)).to.be.instanceOf(_types.NumberType);
		});

		it("can assign values to an array element", function () {
			var _inferTypes26 = inferTypes(`
			const numbers = [];
			numbers[0] = 4;
			`);

			const scope = _inferTypes26.scope;
			const typeEnvironment = _inferTypes26.typeEnvironment;

			// assert

			const numbers = scope.resolveSymbol("numbers");

			(0, _chai.expect)(typeEnvironment.getType(numbers)).to.be.instanceOf(_types.ArrayType).and.has.property("of").that.is.an.instanceOf(_types.NumberType);
		});

		it("can add values to an array", function () {
			var _inferTypes27 = inferTypes(`
			const numbers = [];
			numbers.push(3);
			`);

			const scope = _inferTypes27.scope;
			const typeEnvironment = _inferTypes27.typeEnvironment;

			// assert

			const numbers = scope.resolveSymbol("numbers");

			(0, _chai.expect)(typeEnvironment.getType(numbers)).to.be.instanceOf(_types.ArrayType).and.has.property("of").that.is.an.instanceOf(_types.NumberType);
		});

		it("can invoke array methods", function () {
			var _inferTypes28 = inferTypes(`
			const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
			const even = numbers.filter(function (n) { return n % 2 == 0; });
			const mapped = numbers.map(function (n) { return [n]; });
			const summed = numbers.reduce(function (current, n) { return current + n; }, 0); 
			`);

			const scope = _inferTypes28.scope;
			const typeEnvironment = _inferTypes28.typeEnvironment;

			// assert

			const even = scope.resolveSymbol("even");
			const mapped = scope.resolveSymbol("mapped");
			const sum = scope.resolveSymbol("summed");

			(0, _chai.expect)(typeEnvironment.getType(even)).to.be.instanceOf(_types.ArrayType).and.has.property("of").that.is.an.instanceOf(_types.NumberType);
			(0, _chai.expect)(typeEnvironment.getType(mapped)).to.be.instanceOf(_types.ArrayType).and.has.property("of").that.is.an.instanceOf(_types.ArrayType);
			(0, _chai.expect)(typeEnvironment.getType(sum)).to.be.instanceOf(_types.NumberType);
		});
	});

	/**
  * Infers the types for the given code and returns the type environment, ast and the scope of the source file
  * @param code the source code for which the types should be inferred.
  * @throws {TypeInferenceError} if a type cannot be unified with another (a type checker error)
  * @returns {{typeEnvironment: TypeEnvironment, scope: Scope, ast: {}} the analysed source file
  */
	function inferTypes(code) {
		const program = new _program.Program();
		const sourceFile = program.createSourceFile("./type-inference.integration-test.js", code);

		const typeEnvironments = (0, _infer.infer)(sourceFile, program);
		const typeEnv = typeEnvironments.get(null) || _typeEnvironment.TypeEnvironment.EMPTY;
		return { typeEnvironment: typeEnv, scope: sourceFile.scope, ast: sourceFile.ast, typeEnvironments: typeEnvironments };
	}
});
//# sourceMappingURL=forward-type-inference-analysis.integration.spec.js.map
