"use strict";

var _util = require("../lib/util");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _babelTraverse = require("babel-traverse");

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babylon = require("babylon");

var _chai = require("chai");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("util", function () {
	describe("createTraverseVisitorWrapper", function () {
		let ast;

		beforeEach(function () {
			ast = (0, _babylon.parse)(`
			let x, y;
			x = 10;
			`);
		});

		it("calls the enter callback for a node", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				enterExpressionStatement: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper);

			// assert
			_sinon2.default.assert.called(visitorObject.enterVariableDeclaration);
		});

		it("passes the path to the handler", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				enterExpressionStatement: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper);

			// assert
			_sinon2.default.assert.calledWith(visitorObject.enterVariableDeclaration, _sinon2.default.match.instanceOf(_babelTraverse.NodePath));
		});

		it("passes the context to the handler", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				enterExpressionStatement: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper, null, {});

			// assert
			_sinon2.default.assert.calledWith(visitorObject.enterVariableDeclaration, _sinon2.default.match.instanceOf(_babelTraverse.NodePath), _sinon2.default.match.object);
		});

		it("ensures that this stays the same", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				enterExpressionStatement: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper, null, {});

			// assert
			(0, _chai.expect)(visitorObject.enterVariableDeclaration.thisValues[0]).to.equal(visitorObject);
		});

		it("registers the exit handler if the object has an exit handler", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				exitVariableDeclaration: _sinon2.default.spy(),
				enterExpressionStatement: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper);

			// assert
			_sinon2.default.assert.called(visitorObject.exitVariableDeclaration);
			_sinon2.default.assert.called(visitorObject.enterVariableDeclaration);
		});

		it("calls the default callback if no specific handler exists", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act
			(0, _babelTraverse2.default)(ast, wrapper);

			// assert
			_sinon2.default.assert.calledWith(visitorObject.defaultHandler, _sinon2.default.match.has("node", ast.program.body[1]));
		});

		it("throws when a visitor object has a public method that is not a node type", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				enterXYHandler: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			// act, assert
			(0, _chai.expect)(() => (0, _util.createTraverseVisitorWrapper)(visitorObject)).to.throw("AssertionError: 'Unknown Node type");
		});

		it("does not throw an error for private visitor functions prefixed with _", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy(),
				_helper: _sinon2.default.spy(),
				defaultHandler: _sinon2.default.spy()
			};

			// act, assert
			(0, _chai.expect)(() => (0, _util.createTraverseVisitorWrapper)(visitorObject)).not.to.throw;
		});

		it("fails when the visitor does not have a default handler and a not handled node is traversed", function () {
			// arrange
			const visitorObject = {
				enterVariableDeclaration: _sinon2.default.spy()
			};

			const wrapper = (0, _util.createTraverseVisitorWrapper)(visitorObject);

			// act, assert
			(0, _chai.expect)(() => (0, _babelTraverse2.default)(ast, wrapper)).to.throw("AssertionError: 'Unhandled node type Program.'");
		});
	});
});
//# sourceMappingURL=util.spec.js.map
