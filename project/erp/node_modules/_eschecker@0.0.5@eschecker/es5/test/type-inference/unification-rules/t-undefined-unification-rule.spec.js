"use strict";

var _chai = require("chai");

var _tUndefinedUnificationRule = require("../../../lib/type-inference/unification-rules/t-undefined-unification-rule");

var _types = require("../../../lib/semantic-model/types");

describe("TUndefinedUnificationRule", function () {
	let rule;

	beforeEach(function () {
		rule = new _tUndefinedUnificationRule.TUndefinedUnificationRule();
	});

	describe("canUnify", function () {
		it("returns true if one of the types is undefined", function () {
			(0, _chai.expect)(rule.canUnify(_types.StringType.create(), _types.VoidType.create())).to.be.true;
			(0, _chai.expect)(rule.canUnify(_types.VoidType.create(), _types.StringType.create())).to.be.true;
		});

		it("returns false if the other type is any", function () {
			(0, _chai.expect)(rule.canUnify(_types.AnyType.create(), _types.VoidType.create())).to.be.false;
			(0, _chai.expect)(rule.canUnify(_types.VoidType.create(), _types.AnyType.create())).to.be.false;
		});

		it("returns false if neither of the types is VoidType", function () {
			(0, _chai.expect)(rule.canUnify(_types.StringType.create(), _types.StringType.create())).to.be.false;
		});
	});

	describe("unify", function () {
		it("returns t1 if t2 is VoidType", function () {
			// arrange
			const t1 = _types.StringType.create();
			const t2 = _types.VoidType.create();

			// assert
			(0, _chai.expect)(rule.unify(t1, t2)).to.equal(t1);
		});

		it("returns t2 if t1 is VoidType", function () {
			// arrange
			const t1 = _types.VoidType.create();
			const t2 = _types.StringType.create();

			// assert
			(0, _chai.expect)(rule.unify(t1, t2)).to.equal(t2);
		});
	});
});
//# sourceMappingURL=t-undefined-unification-rule.spec.js.map
