"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _binaryOperators = require("../../../lib/type-inference/refinement-rules/binary-operators");

var _binaryOperators2 = _interopRequireDefault(_binaryOperators);

var _types = require("../../../lib/semantic-model/types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("BinaryOperators", function () {
	let operator, unify;

	beforeEach(function () {
		unify = _sinon2.default.stub();
		unify.returnsArg(0);
	});

	for (const numberOperator of ["+", "-", "*", "/", "<<", ">>", ">>>", "%", "|", "^", "&", "<", ">", "<=", ">="]) {
		describe(numberOperator, function () {

			beforeEach(function () {
				operator = _binaryOperators2.default[numberOperator];
			});

			it(`is registered with the name ${ numberOperator }`, function () {
				(0, _chai.expect)(_binaryOperators2.default).to.have.property(numberOperator);
			});

			it("refines the type to NumberType", function () {
				// arrange
				const leftParameter = _types.NullType.create();
				const rightParameter = _types.MaybeType.of(_types.NumberType.create());

				// act
				const refined = operator.refine(leftParameter, rightParameter, unify);

				// assert
				(0, _chai.expect)(refined).to.be.instanceOf(_types.NumberType);
			});

			it("calls unify for the left- and right parameter together with the operator type", function () {
				// arrange
				const leftParameter = _types.MaybeType.of(_types.NumberType.create());
				const rightParameter = _types.MaybeType.of(_types.NumberType.create());

				// act
				operator.refine(leftParameter, rightParameter, unify);

				// assert
				_sinon2.default.assert.calledWithExactly(unify, leftParameter, _sinon2.default.match.instanceOf(_types.MaybeType));
				_sinon2.default.assert.calledWithExactly(unify, _sinon2.default.match.instanceOf(_types.MaybeType), rightParameter);
			});
		});
	}

	for (const op of ["===", "!=="]) {
		describe(op, function () {
			beforeEach(function () {
				operator = _binaryOperators2.default[op];
			});

			it(`is registered with the name ${ op }`, function () {
				(0, _chai.expect)(_binaryOperators2.default).to.have.property(op);
			});

			it("returns BoolType as operator result", function () {
				// arrange
				const leftType = _types.NumberType.create();
				const rightType = _types.NumberType.create();

				// act
				const refined = operator.refine(leftType, rightType, unify);

				// assert
				(0, _chai.expect)(refined).to.be.instanceOf(_types.BooleanType);
			});

			it("fails if the right and left parameter type cannot be unified", function () {
				// arrange
				const leftType = _types.NumberType.create();
				const rightType = _types.StringType.create();

				unify.throws(new Error("Unification of string and number not possible"));

				// act
				(0, _chai.expect)(() => operator.refine(leftType, rightType, unify)).to.throw("Unification of string and number not possible");
			});
		});
	}

	for (const op of ["==", "!="]) {
		describe(op, function () {
			beforeEach(function () {
				operator = _binaryOperators2.default[op];
			});

			it(`is registered with the name ${ op }`, function () {
				(0, _chai.expect)(_binaryOperators2.default).to.have.property(op);
			});

			it("returns BoolType as operator result", function () {
				// arrange
				const leftType = _types.NumberType.create();
				const rightType = _types.NumberType.create();

				// act
				const refined = operator.refine(leftType, rightType, unify);

				// assert
				(0, _chai.expect)(refined).to.be.instanceOf(_types.BooleanType);
			});
		});
	}
});
//# sourceMappingURL=binary-operators.spec.js.map
