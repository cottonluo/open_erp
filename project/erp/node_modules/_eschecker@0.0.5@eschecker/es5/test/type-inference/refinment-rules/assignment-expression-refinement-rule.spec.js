"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _binaryOperators = require("../../../lib/type-inference/refinement-rules/binary-operators");

var _binaryOperators2 = _interopRequireDefault(_binaryOperators);

var _hindleyMilnerContext = require("../../../lib/type-inference/hindley-milner-context");

var _assignmentExpressionRefinementRule = require("../../../lib/type-inference/refinement-rules/assignment-expression-refinement-rule");

var _types = require("../../../lib/semantic-model/types");

var _symbol = require("../../../lib/semantic-model/symbol");

var _program = require("../../../lib/semantic-model/program");

var _program2 = _interopRequireDefault(_program);

var _typeInferenceContext = require("../../../lib/type-inference/type-inference-context");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("AssignmentExpressionRefinementRule", function () {
	let rule, context, program, assignmentExpression, sandbox;

	beforeEach(function () {
		program = new _program2.default();
		context = new _hindleyMilnerContext.HindleyMilnerContext(null, new _typeInferenceContext.TypeInferenceContext(program));

		sandbox = _sinon2.default.sandbox.create();
		sandbox.stub(context, "unify");
		sandbox.stub(context, "infer");

		rule = new _assignmentExpressionRefinementRule.AssignmentExpressionRefinementRule();
		assignmentExpression = t.assignmentExpression("=", t.identifier("x"), t.numericLiteral(5));
	});

	afterEach(function () {
		sandbox.restore();
	});

	describe("canRefine", function () {
		it("returns true for a assignment expression", function () {
			(0, _chai.expect)(rule.canRefine(assignmentExpression)).to.be.true;
		});

		it("returns false otherwise", function () {
			(0, _chai.expect)(rule.canRefine(t.numericLiteral(4))).to.be.false;
		});
	});

	describe("refine", function () {
		describe("=", function () {
			it("returns the type of the right hand side if the left hand side is a type variable", function () {
				// arrange
				const xSymbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(assignmentExpression.left, xSymbol);
				context.unify.returnsArg(0);
				context.infer.returns(_types.NumberType.create());

				// act, assert
				(0, _chai.expect)(rule.refine(assignmentExpression, context)).to.be.instanceOf(_types.NumberType);
			});

			it("sets the type of the assignee in the type environment", function () {
				// arrange
				const xSymbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(assignmentExpression.left, xSymbol);
				context.infer.returns(_types.NumberType.create());

				// act
				rule.refine(assignmentExpression, context);

				// assert
				(0, _chai.expect)(context.getType(xSymbol)).to.be.instanceOf(_types.NumberType);
			});

			it("sets a fresh type of the assignee in the type environment", function () {
				// arrange
				const xSymbol = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(assignmentExpression.left, xSymbol);

				const xType = _types.TypeVariable.create();
				context.infer.returns(xType);

				// act
				rule.refine(assignmentExpression, context);

				// assert
				(0, _chai.expect)(context.getType(xSymbol)).to.be.instanceOf(_types.TypeVariable).and.not.to.equal(xType);
			});
		});

		describe("BinaryOperatorAssignment", function () {
			it("throws if the operator is not supported", function () {
				// arrange
				const illegalAssignmentOperator = t.assignmentExpression("$=", t.identifier("x"), t.numericLiteral(4));

				// act, assert
				(0, _chai.expect)(() => rule.refine(illegalAssignmentOperator, context)).to.throw("Type inference failure: The assignment operator $= is not supported");
			});

			it("uses the binary operator with the given name to refine the type", function () {
				// arrange
				const plusAssignment = t.assignmentExpression("+=", t.identifier("x"), t.numericLiteral(4));
				const xType = _types.NullType.create();
				const numberType = _types.NumberType.create();
				program.symbolTable.setSymbol(plusAssignment.left, new _symbol.Symbol("x", _symbol.SymbolFlags.Variable));

				sandbox.stub(_binaryOperators2.default["+"], "refine").returns(_types.NumberType.create());

				context.infer.withArgs(plusAssignment.left).returns(xType);
				context.infer.withArgs(plusAssignment.right).returns(numberType);

				// act
				const refined = rule.refine(plusAssignment, context);

				// assert
				_sinon2.default.assert.calledWithExactly(_binaryOperators2.default["+"].refine, xType, numberType, _sinon2.default.match.func);
				(0, _chai.expect)(refined).to.be.instanceOf(_types.NumberType);
			});

			it("sets the (updated) type for the assignee in the type environment", function () {
				// arrange
				const plusAssignment = t.assignmentExpression("+=", t.identifier("x"), t.numericLiteral(4));
				const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);

				program.symbolTable.setSymbol(plusAssignment.left, x);

				const xType = _types.NullType.create();
				const numberType = _types.NumberType.create();

				context.infer.withArgs(plusAssignment.left).returns(xType);
				context.infer.withArgs(plusAssignment.right).returns(numberType);
				sandbox.stub(_binaryOperators2.default["+"], "refine").returns(numberType);

				// act
				rule.refine(plusAssignment, context);

				// assert
				(0, _chai.expect)(context.getType(x)).to.be.instanceOf(_types.NumberType);
			});
		});

		describe("members", function () {
			let memberExpression = t.memberExpression(t.identifier("person"), t.identifier("name"));
			let assignmentToMember = t.assignmentExpression("=", memberExpression, t.stringLiteral("Micha"));

			it("replaces the record of the target object with one that includes the new property", function () {
				// arrange
				const personSymbol = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
				const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
				personSymbol.addMember(name);

				const person = new _types.RecordType();

				program.symbolTable.setSymbol(memberExpression.object, personSymbol);
				program.symbolTable.setSymbol(memberExpression.property, name);

				context.setType(personSymbol, person);

				context.infer.withArgs(assignmentToMember.right).returns(_types.StringType.create());
				context.infer.withArgs(memberExpression.object).returns(person);

				// act, assert
				(0, _chai.expect)(rule.refine(assignmentToMember, context)).to.be.instanceOf(_types.StringType);
				(0, _chai.expect)(context.getType(personSymbol).getType(name)).to.be.instanceOf(_types.StringType);
			});

			it("updates the type of the property if the target object already has a property with the same name", function () {
				// arrange
				const personSymbol = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
				const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
				personSymbol.addMember(name);
				const person = new _types.RecordType();
				person.addProperty(name, _types.NullType.create());

				program.symbolTable.setSymbol(memberExpression.object, personSymbol);
				program.symbolTable.setSymbol(memberExpression.property, name);
				context.setType(personSymbol, person);

				context.infer.withArgs(assignmentToMember.right).returns(_types.StringType.create());
				context.infer.withArgs(memberExpression.object).returns(person);

				// act, assert
				(0, _chai.expect)(rule.refine(assignmentToMember, context)).to.be.instanceOf(_types.StringType);
				(0, _chai.expect)(context.getType(personSymbol).getType(name)).to.be.instanceOf(_types.StringType);
			});

			it("does  not add a member if the object type is any", function () {
				// arrange
				const personSymbol = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
				const name = new _symbol.Symbol("name", _symbol.SymbolFlags.Property);
				personSymbol.addMember(name);

				const person = _types.AnyType.create();

				program.symbolTable.setSymbol(memberExpression.object, personSymbol);
				program.symbolTable.setSymbol(memberExpression.property, name);

				context.setType(personSymbol, person);

				context.infer.withArgs(assignmentToMember.right).returns(_types.StringType.create());
				context.infer.withArgs(memberExpression.object).returns(person);

				// act, assert
				(0, _chai.expect)(rule.refine(assignmentToMember, context)).to.be.instanceOf(_types.StringType);
			});
		});
	});
});
//# sourceMappingURL=assignment-expression-refinement-rule.spec.js.map
