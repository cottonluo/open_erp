"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _typeUnificator = require("../../lib/type-inference/type-unificator");

var _index = require("../../lib/semantic-model/types/index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("TypeUnificator", function () {
	describe("common", function () {

		it("resolves the unification rules from the unification-rules directory", function () {
			// act
			const unificator = new _typeUnificator.TypeUnificator();

			// assert
			(0, _chai.expect)(unificator.baseTypeUnificationRules.toArray()).not.to.be.empty;
		});

		it("returns if the passed in types are equal", function () {
			// arrange
			const numberType = new _index.Type("number");
			const otherNumberType = new _index.Type("number");
			const unificator = new _typeUnificator.TypeUnificator();

			_sinon2.default.stub(numberType, "equals").returns(true);

			// act
			const unified = unificator.unify(numberType, otherNumberType);

			// assert
			(0, _chai.expect)(unified).to.equal(numberType);
		});
	});

	describe("unifying type variable with base type", function () {
		it("returns the base type when the first type is a base type and the second is a type variable", function () {
			// arrange
			const typeUnificator = new _typeUnificator.TypeUnificator();
			const typeVariable = new _index.TypeVariable();
			const numberType = _index.NumberType.create();

			// act
			const unified = typeUnificator.unify(numberType, typeVariable);

			// assert
			(0, _chai.expect)(unified).to.equal(numberType);
		});

		it("returns the base type when the first type is a type variable and the second is a base type", function () {
			// arrange
			const typeUnificator = new _typeUnificator.TypeUnificator();
			const typeVariable = new _index.TypeVariable();
			const numberType = _index.NumberType.create();

			// act
			const unified = typeUnificator.unify(typeVariable, numberType);

			// assert
			(0, _chai.expect)(unified).to.equal(numberType);
		});

		it("throws when the type variable is part of the other type definition with which it should be unified", function () {
			// arrange
			const typeUnificator = new _typeUnificator.TypeUnificator();
			const typeVariable = new _index.TypeVariable(1);
			const maybeType = _index.MaybeType.of(typeVariable);

			// act, assert
			(0, _chai.expect)(() => typeUnificator.unify(maybeType, typeVariable)).to.throw("Unification for type '@ (1)' and 'Maybe<@ (1)>' failed because The type variable of t1 is contained inside of the type t2 and therefore cannot be replaced by t2.");
		});
	});

	describe("unifying two type variables", function () {
		it("resolves the first type variable to the second (t1 is an alias for t2)", function () {
			// arrange
			const typeUnificator = new _typeUnificator.TypeUnificator();
			const typeVariable = new _index.TypeVariable();
			const secondTypeVariable = new _index.TypeVariable();

			// act
			const unified = typeUnificator.unify(typeVariable, secondTypeVariable);

			// assert
			(0, _chai.expect)(unified).to.equal(secondTypeVariable);
		});
	});

	describe("unifying two base types", function () {
		let typeUnificator, rule1, rule2;

		beforeEach(function () {
			rule1 = { canUnify: _sinon2.default.stub(), unify: _sinon2.default.stub() };
			rule2 = { canUnify: _sinon2.default.stub(), unify: _sinon2.default.stub() };
			typeUnificator = new _typeUnificator.TypeUnificator([rule1, rule2]);
		});

		it("uses the base unification rule that can unify the given two base types", function () {
			// arrange
			const numberType = _index.NumberType.create();
			const maybeType = _index.MaybeType.of(numberType);

			rule1.canUnify.returns(true);
			rule1.unify.returns(maybeType);

			rule2.canUnify.returns(false);

			// act
			const unified = typeUnificator.unify(numberType, maybeType);

			// assert
			_sinon2.default.assert.calledWith(rule1.unify, numberType, maybeType);
			(0, _chai.expect)(unified).to.equal(maybeType);
		});

		it("throws if no rule can be used for unifying the two base types", function () {
			// arrange
			const numberType = _index.NumberType.create();
			const maybeType = _index.MaybeType.of(numberType);

			rule1.canUnify.returns(false);
			rule2.canUnify.returns(false);

			// act, assert
			(0, _chai.expect)(() => typeUnificator.unify(numberType, maybeType)).to.throw("Unification for type 'number' and 'Maybe<number>' failed because there exists no rule that can be used to unify the given types.");
		});

		it("throws if when more then one rule can be used for unifying the two base types", function () {
			// arrange
			const numberType = _index.NumberType.create();
			const maybeType = _index.MaybeType.of(numberType);

			rule1.canUnify.returns(true);
			rule2.canUnify.returns(true);

			// act, assert
			(0, _chai.expect)(() => typeUnificator.unify(numberType, maybeType)).to.throw("Unification for type 'number' and 'Maybe<number>' failed because unification rule to use is ambiguous(Object,Object).");
		});
	});
});
//# sourceMappingURL=type-unificator.spec.js.map
