"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.UnaryExpressionRefinementRule = undefined;

var _types = require("../../semantic-model/types");

var _typeInferenceError = require("../type-inference-error");

/**
 * Refinement Rule for unary expressions
 * @implements {RefinementRule}
 */
class UnaryExpressionRefinementRule {
	canRefine(node) {
		return node.type === "UnaryExpression";
	}

	refine(node, context) {
		const argumentType = context.infer(node.argument);

		switch (node.operator) {
			case "void":
				return _types.VoidType.create();
			case "+":
			case "-":
			case "~":
				context.unify(argumentType, _types.NumberType.create(), node);
				return _types.NumberType.create();
			case "!":
				return _types.BooleanType.create();
			case "typeof":
				return _types.StringType.create();
			default:
				throw new _typeInferenceError.TypeInferenceError(`The operator ${ node.operator } for unary expressions is not yet supported`, node);
		}
	}
}

exports.UnaryExpressionRefinementRule = UnaryExpressionRefinementRule;
exports.default = UnaryExpressionRefinementRule;
//# sourceMappingURL=unary-expression-refinement-rule.js.map
