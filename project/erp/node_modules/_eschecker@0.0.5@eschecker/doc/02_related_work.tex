\section{Related Work}\label{sec:related-work}
This work is related to linters, transpiled languages and other type checkers for JavaScript. 

Linters like ESLint~\cite{jQuery2016} are used to enforce a specific coding style across a project or to find errors using common bug patterns. Linters use simple static analysis techniques for bug identification. These analysis mostly are intra-procedural. This work focuses on errors deducible by type checking, based on a sophisticated inter-procedural analysis. 


An alternative and quite popular approach for type checking programs executing in a JavaScript environment is by transpiling a source language to JavaScript. The source language either allows type inference~\cite{Ekblad2012, McKenna} or uses type annotations. Well-known examples are TypeScript~\cite{Microsoft2012} and Flow~\cite{Facebook2014}. The downside of a transpiled language is the need for an additional build step that slows down the development cycle and is a potential source for errors. A developer using a transpiled language needs to have a good understanding of the source language and JavaScript. This limits the amount of potential programmers or requires additional training. This work differs from transpilers as the focus is on type checking JavaScript and not transpiled languages.

TAJS~\cite{JensenMollerThiemann2009} is a sound type analyzer and type checker for JavaScript. The used algorithm is context and path-sensitive. TAJS uses abstract interpretation for type inference. The goal of TAJS is a precise and sound type checker that supports the full JavaScript language. The current version only supports ECMAScript 3 and a limited set of ECMAScript 5. Compared to TAJS, this works focuses on JavaScript programs using ECMAScript 6 and strict mode. Furthermore, the presented analysis is unsound to reduce the number of false positives.

Infernu~\cite{Lewis} implements type inference and type checking for JavaScript. It uses the Hindley-Milner algorithm. The used type system only models a limited set of JavaScript. The subset is defined by the properties required by the Hindley-Milner algorithm. For instance, the unmodified Hindley-Milner algorithm requires that a variable has exactly one type in a program, the principal type. Therefore, Infernu disallows assigning values of different types to the same variable, contrary to the JavaScript specification. This works differs from Infernu as it extends the Hindley-Milner algorithm to support a wider set of JavaScript programs and reduce the number of false positives.

\citeauthor{Odgaard2014} describes in his master thesis a dynamic analysis for type inference~\cite{Odgaard2014}. The presented analysis uses code instrumentation to obtain the runtime values and derives the variable types from these. The inferred types are used to add JSDoc~\cite{JSDoc} type annotations. Compared to the approach presented by the work of \citeauthor{Odgaard2014}, this work uses static over dynamic analysis for type inference. 

Tern~\cite{Haverbeke} is an editor-independent JavaScript analyzer with type inference. It only provides an API for editors but does not perform type checking. Editors can use the API of Tern to query type-information, provide auto-completion, and jump-to-definition functionality. Tern uses abstract values and abstract interpretation for type inference. Tern can only infer types for functions with an actual invocation. Non-invoked functions are not analyzed. This work differs from Tern as the project focuses on type checking and not on providing an API for editors. 