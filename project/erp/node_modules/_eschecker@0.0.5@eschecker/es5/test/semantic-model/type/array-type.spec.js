"use strict";

var _chai = require("chai");

var _symbol = require("../../../lib/semantic-model/symbol");

var _types = require("../../../lib/semantic-model/types");

describe("ArrayType", function () {
	describe("prettyName", function () {
		it("returns T[] where T is the type of the array", function () {
			(0, _chai.expect)(_types.ArrayType.of(_types.StringType.create()).prettyName).to.equals("string[]");
		});
	});

	describe("isSubType", function () {
		it("returns true if the array types are equal", function () {
			// arrange
			const a1 = _types.ArrayType.of(_types.StringType.create());
			const a2 = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(a1.isSubType(a2)).to.be.true;
			(0, _chai.expect)(a2.isSubType(a1)).to.be.true;
		});

		it("returns true for T[].isSubType(S[]) if S is a subtype of T", function () {
			// arrange
			const a1 = _types.ArrayType.of(_types.MaybeType.of(_types.StringType.create()));
			const a2 = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(a1.isSubType(a2)).to.be.true;
		});

		it("returns false for T[].isSubType(U[]) where U is not a subtype of T", function () {
			// arrange
			const a1 = _types.ArrayType.of(_types.StringType.create());
			const a2 = _types.ArrayType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(a1.isSubType(a2)).to.be.false;
		});
	});

	describe("substitute", function () {
		it("returns the new type if the type to substitute is this", function () {
			// arrange
			const tOld = _types.ArrayType.of(new _types.TypeVariable());
			const tNew = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(tOld.substitute(tOld, tNew)).to.equals(tNew);
		});

		it("substitutes the type in the of type parameter", function () {
			// arrange
			const array = _types.ArrayType.of(new _types.TypeVariable());
			const ofNew = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(array.substitute(array.of, ofNew)).to.be.an.instanceOf(_types.ArrayType).that.has.property("of").that.is.an.instanceOf(_types.StringType);
		});

		it("returns this if the type does not occurr in this", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.substitute(new _types.TypeVariable(), _types.NumberType.create())).to.equals(array);
		});

		it("substitutes the type in the properties of the type", function () {
			// arrange
			const description = new _symbol.Symbol("description", _symbol.SymbolFlags.Property & _symbol.SymbolFlags.Function);
			const array = _types.ArrayType.of(_types.StringType.create()).addProperty(description, new _types.TypeVariable());
			const newPropertyType = _types.StringType.create();

			// act, assert
			const substituted = array.substitute(array.getType(description), newPropertyType);
			(0, _chai.expect)(substituted.getType(description)).to.equals(newPropertyType);
		});
	});

	describe("containsType", function () {
		it("returns true if the type is contained in the of type", function () {
			// arrange
			const array = _types.ArrayType.of(new _types.TypeVariable());

			// act, assert
			(0, _chai.expect)(array.containsType(array.of)).to.be.true;
		});

		it("returns false if the type is not contained in the of type or in any property", function () {
			// arrange
			const array = _types.ArrayType.of(new _types.TypeVariable());

			// act, assert
			(0, _chai.expect)(array.containsType(_types.StringType.create())).to.be.false;
		});

		it("returns true if the type is contained in a property", function () {
			// arrange
			const description = new _symbol.Symbol("description", _symbol.SymbolFlags.Property & _symbol.SymbolFlags.Function);
			const array = _types.ArrayType.of(_types.StringType.create()).addProperty(description, new _types.TypeVariable());

			// act, assert
			(0, _chai.expect)(array.containsType(array.getType(description))).to.be.true;
		});
	});

	describe("equals", function () {
		it("returns true if the type has the same properties and has the same element type", function () {
			// arrange
			const description = new _symbol.Symbol("description", _symbol.SymbolFlags.Property & _symbol.SymbolFlags.Function);
			const array1 = _types.ArrayType.of(_types.StringType.create()).addProperty(description, _types.StringType.create());

			const array2 = _types.ArrayType.of(_types.StringType.create()).addProperty(description, _types.StringType.create());

			// act, assert
			(0, _chai.expect)(array1.equals(array2)).to.be.true;
			(0, _chai.expect)(array2.equals(array1)).to.be.true;
		});

		it("is false if the element type of the arrays does not match", function () {
			// arrange
			const description = new _symbol.Symbol("description", _symbol.SymbolFlags.Property & _symbol.SymbolFlags.Function);
			const array1 = _types.ArrayType.of(_types.StringType.create()).addProperty(description, _types.StringType.create());

			const array2 = _types.ArrayType.of(_types.NumberType.create()).addProperty(description, _types.StringType.create());

			// act, assert
			(0, _chai.expect)(array1.equals(array2)).to.be.false;
			(0, _chai.expect)(array2.equals(array1)).to.be.false;
		});

		it("is false if the type of a property is not equal", function () {
			// arrange
			const description = new _symbol.Symbol("description", _symbol.SymbolFlags.Property & _symbol.SymbolFlags.Function);
			const array1 = _types.ArrayType.of(_types.StringType.create()).addProperty(description, _types.StringType.create());

			const array2 = _types.ArrayType.of(_types.StringType.create()).addProperty(description, _types.NumberType.create());

			// act, assert
			(0, _chai.expect)(array1.equals(array2)).to.be.false;
			(0, _chai.expect)(array2.equals(array1)).to.be.false;
		});
	});

	describe("hasProperty", function () {
		it("returns true for built in properties", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.hasProperty(new _symbol.Symbol("length"))).to.be.true;
		});

		it("returns false if the array has neither a built in property nor a custom property with the given name", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.hasProperty(new _symbol.Symbol("blabla"))).to.be.false;
		});

		it("returns true if the array has a custom property with the given name", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create()).addProperty(new _symbol.Symbol("bla"), _types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.hasProperty(new _symbol.Symbol("bla"))).to.be.true;
		});
	});

	describe("addProperty", function () {
		it("throws if a built in property should be redefined", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(() => array.addProperty(new _symbol.Symbol("length"), _types.NumberType.create())).to.throw("A property with the name 'length' already exists");
		});
	});

	describe("getType", function () {
		it("returns the type of the built in property if the symbol is for a built in property", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act
			const length = array.getType(new _symbol.Symbol("length"));

			// assert
			(0, _chai.expect)(length).to.be.instanceOf(_types.NumberType);
		});

		it("returns the type of the custom property if the symbol is not for a built in property", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create()).addProperty(new _symbol.Symbol("bla"), _types.NumberType.create());

			// act, assert
			(0, _chai.expect)(array.getType(new _symbol.Symbol("bla"))).to.be.instanceOf(_types.NumberType);
		});

		it("returns the array type if the symbol is a computed symbol", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.getType(_symbol.Symbol.COMPUTED)).to.be.instanceOf(_types.StringType);
		});

		it("returns undefined if neither a built in nor custom property with the given symbole exists", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());

			// act, assert
			(0, _chai.expect)(array.getType(new _symbol.Symbol("bla"))).to.be.undefined;
		});
	});

	describe("setType", function () {
		it("changes the type of the array if the symbol is computed (e.g. a[i], a[2]...)", function () {
			// arrange
			const array = _types.ArrayType.of(_types.TypeVariable.create());

			// act
			const updated = array.setType(_symbol.Symbol.COMPUTED, _types.NumberType.create());

			// assert
			(0, _chai.expect)(updated).to.have.property("of").that.is.an.instanceOf(_types.NumberType).and.not.to.equals(array);
		});

		it("returns a new array with the updated property", function () {
			// arrange
			const array = _types.ArrayType.of(_types.TypeVariable.create()).addProperty(new _symbol.Symbol("bla"), _types.TypeVariable.create());

			// act
			const updated = array.setType(new _symbol.Symbol("bla"), _types.NumberType.create());

			// assert
			(0, _chai.expect)(updated.getType(new _symbol.Symbol("bla"))).to.be.an.instanceOf(_types.NumberType);
			(0, _chai.expect)(updated).not.to.equals(array);
		});

		it("throws if the type of a built in operation should be changed", function () {
			// arrange
			const array = _types.ArrayType.of(_types.TypeVariable.create());

			// act, assert
			(0, _chai.expect)(() => array.setType(new _symbol.Symbol("length"), _types.StringType.create())).to.throw("The type of the built in array property \'length\' cannot be changed");
		});
	});
});
//# sourceMappingURL=array-type.spec.js.map
