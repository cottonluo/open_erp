"use strict";

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _chai = require("chai");

var _arrayUnificationRule = require("../../../lib/type-inference/unification-rules/array-unification-rule");

var _types = require("../../../lib/semantic-model/types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("ArrayUnificationRule", function () {
	let rule, unificator;

	beforeEach(function () {
		rule = new _arrayUnificationRule.ArrayUnificationRule();
		unificator = { unify: _sinon2.default.stub() };
	});

	describe("canUnify", function () {
		it("returns true if both types are array types", function () {
			// arrange
			const array1 = _types.ArrayType.of(_types.StringType.create());
			const array2 = _types.ArrayType.of(_types.NumberType.create());

			// act, assert
			(0, _chai.expect)(rule.canUnify(array1, array2)).to.be.true;
		});

		it("returns false if only one of the types is an array", function () {
			// arrange
			const array = _types.ArrayType.of(_types.StringType.create());
			const string = _types.StringType.create();

			// act, assert
			(0, _chai.expect)(rule.canUnify(array, string)).to.be.false;
			(0, _chai.expect)(rule.canUnify(string, array)).to.be.false;
		});
	});

	describe("unify", function () {
		it("returns t1 if the types are equal", function () {
			// arrange
			const array1 = _types.ArrayType.of(_types.StringType.create());
			const array2 = _types.ArrayType.of(_types.StringType.create());

			unificator.unify.returns(_types.StringType.create());

			// act
			const unified = rule.unify(array1, array2, unificator);

			// assert
			(0, _chai.expect)(unified).to.equals(array1);
		});

		it("returns t1 if the unified type is equal to t1", function () {
			// arrange
			const array1 = _types.ArrayType.of(_types.StringType.create());
			const array2 = _types.ArrayType.of(_types.TypeVariable.create());

			unificator.unify.returns(_types.StringType.create());

			// act
			const unified = rule.unify(array1, array2, unificator);

			// assert
			(0, _chai.expect)(unified).to.equals(array1);
		});

		it("returns t2 if the unified type is equal to t2", function () {
			// arrange
			const array1 = _types.ArrayType.of(_types.TypeVariable.create());
			const array2 = _types.ArrayType.of(_types.StringType.create());

			unificator.unify.returns(_types.StringType.create());

			// act
			const unified = rule.unify(array1, array2, unificator);

			// assert
			(0, _chai.expect)(unified).to.equals(array2);
		});

		it("returns a new array of the unified array type", function () {
			// arrange
			const array1 = _types.ArrayType.of(_types.StringType.create());
			const array2 = _types.ArrayType.of(_types.NullType.create());

			unificator.unify.returns(_types.MaybeType.of(_types.StringType.create()));

			// act
			const unified = rule.unify(array1, array2, unificator);

			// assert
			(0, _chai.expect)(unified).not.to.equals(array1).and.not.to.equals(array2);
			(0, _chai.expect)(unified.of).to.be.an.instanceOf(_types.MaybeType).and.to.have.property("of").that.is.an.instanceOf(_types.StringType);
		});
	});
});
//# sourceMappingURL=array-unification-rule.spec.js.map
