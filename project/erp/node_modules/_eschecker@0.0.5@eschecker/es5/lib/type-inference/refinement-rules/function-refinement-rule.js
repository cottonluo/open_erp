"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.FunctionRefinementRule = undefined;

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _types = require("../../semantic-model/types");

var _controlFlowGraph = require("../../cfg/control-flow-graph");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Refinement rule that handles function declarations, arrow functions and methods.
 * WIP.
 * @implements {RefinementRule}
 */
class FunctionRefinementRule {
	canRefine(node) {
		return t.isFunction(node);
	}

	refine(node, context) {
		let type = context.getType(context.getSymbol(node));
		// The Type of function declarations is extracted before the worklist algorithm as these are hoisted.
		// If a function type is inferred again, return the old type. Otherwise a new function is created each time that
		// that has different type variables and therefore is never equal with the previous definition
		if (!type) {
			type = FunctionRefinementRule.inferFunctionType(node, context);
		}

		// set the updated type environment from the declaration
		type.typeEnvironment = context.typeEnvironment; // the type needs to contain it's own declaration

		return type;
	}

	static _getParameterTypes(node) {
		return node.params.map(() => _types.TypeVariable.create());
	}

	static _getReturnType(node, context) {
		if (node.expression || this._allNonExceptionExitsWithExplicitReturnStatement(node.body, context)) {
			return _types.TypeVariable.create();
		}
		// at least one exit node has a non explicit return value and therefore the function might return void
		return _types.VoidType.create();
	}

	static _allNonExceptionExitsWithExplicitReturnStatement(node, context) {
		const cfg = context.getCfg(node);
		const cfgNode = cfg.getNode(node);
		const exitEdges = Array.from(cfg.getExitEdges(cfgNode));

		for (const exitEdge of exitEdges) {
			if (!t.isReturnStatement(exitEdge.src.value) && exitEdge.branch !== _controlFlowGraph.BRANCHES.EXCEPTION) {
				return false;
			}
		}

		return exitEdges.length > 0;
	}

	static inferFunctionType(node, context) {
		const parameterTypes = this._getParameterTypes(node);
		const returnType = this._getReturnType(node, context);
		const type = new _types.FunctionType(_types.TypeVariable.create(), parameterTypes, returnType, node);

		context.setType(context.getSymbol(node), type);

		return type;
	}
}

exports.FunctionRefinementRule = FunctionRefinementRule;
exports.default = FunctionRefinementRule;
//# sourceMappingURL=function-refinement-rule.js.map
