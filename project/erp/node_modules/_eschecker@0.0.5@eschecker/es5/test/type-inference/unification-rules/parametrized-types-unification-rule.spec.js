"use strict";

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _parametrizedTypesUnificationRule = require("../../../lib/type-inference/unification-rules/parametrized-types-unification-rule");

var _parametrizedTypesUnificationRule2 = _interopRequireDefault(_parametrizedTypesUnificationRule);

var _index = require("../../../lib/semantic-model/types/index");

var _hindleyMilnerContext = require("../../../lib/type-inference/hindley-milner-context");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("ParametrizedTypesUnificationRule", function () {
	let rule, context;

	beforeEach(function () {
		rule = new _parametrizedTypesUnificationRule2.default();
		context = new _hindleyMilnerContext.HindleyMilnerContext();
		_sinon2.default.stub(context, "unify");
	});

	describe("canUnify", function () {
		it("returns true if both types are parametrized types", function () {
			// arrange
			const t1 = new TestParametrizedType("Maybe", [_index.NumberType.create()]);
			const t2 = new TestParametrizedType("Maybe", [_index.StringType.create()]);

			// act, assert
			(0, _chai.expect)(rule.canUnify(t1, t2)).to.be.true;
		});

		it("returns false if t1 not a parametrized type", function () {
			// arrange
			const t1 = _index.StringType.create();
			const t2 = new TestParametrizedType("Maybe", [_index.NumberType.create()]);

			// act, assert
			(0, _chai.expect)(rule.canUnify(t1, t2)).to.be.false;
		});

		it("returns false if t2 not a parametrized type", function () {
			// arrange
			const t1 = new TestParametrizedType("Maybe", [_index.NumberType.create()]);
			const t2 = _index.StringType.create();

			// act, assert
			(0, _chai.expect)(rule.canUnify(t1, t2)).to.be.false;
		});
	});

	describe("unify", function () {
		it("returns t1 if the type parameters are equal", function () {
			// arrange
			const typeParameter1 = _index.NumberType.create();
			const typeParameter2 = _index.NumberType.create();
			const t1 = new TestParametrizedType("Maybe", [typeParameter1]);
			const t2 = new TestParametrizedType("Maybe", [typeParameter2]);

			context.unify.returnsArg(0);

			// act, assert
			(0, _chai.expect)(rule.unify(t1, t2, context)).to.equal(t1);
		});

		it("unifies all type parameters", function () {
			// arrange
			const typeParameter1 = _index.NumberType.create();
			const typeParameter2 = _index.NumberType.create();

			const t1 = new TestParametrizedType("Maybe", [typeParameter1]);
			const t2 = new TestParametrizedType("Maybe", [typeParameter2]);

			// act
			rule.unify(t1, t2, context);

			// assert
			_sinon2.default.assert.calledWith(context.unify, typeParameter1, typeParameter2);
		});

		it("fails if the types have not the same number of type parameters", function () {
			const t1 = new TestParametrizedType("Maybe", [_index.NumberType.create()]);
			const t2 = new TestParametrizedType("Maybe", [_index.NumberType.create(), _index.StringType.create()]);

			// act, assert
			(0, _chai.expect)(() => rule.unify(t1, t2, context)).to.throw("Unification for type 'Maybe<number>' and 'Maybe<number, string>' failed because the parametrized types have a different number of type parameters and therefore cannot be unified.");
		});
	});
});

class TestParametrizedType extends _index.ParametrizedType {
	constructor(name, typeParameters, id) {
		super(name, id);
		this._typeParameters = typeParameters;
	}

	get typeParameters() {
		return this._typeParameters;
	}

	withTypeParameters(value, id) {
		return new TestParametrizedType(this.name, ...value, id);
	}
}
//# sourceMappingURL=parametrized-types-unification-rule.spec.js.map
