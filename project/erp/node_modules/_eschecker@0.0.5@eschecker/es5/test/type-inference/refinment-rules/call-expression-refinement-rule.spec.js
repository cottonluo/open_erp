"use strict";

var _babelTypes = require("babel-types");

var t = _interopRequireWildcard(_babelTypes);

var _chai = require("chai");

var _sinon = require("sinon");

var _sinon2 = _interopRequireDefault(_sinon);

var _callExpressionRefinementRule = require("../../../lib/type-inference/refinement-rules/call-expression-refinement-rule");

var _hindleyMilnerContext = require("../../../lib/type-inference/hindley-milner-context");

var _typeInferenceContext = require("../../../lib/type-inference/type-inference-context");

var _typeEnvironment = require("../../../lib/type-inference/type-environment");

var _program = require("../../../lib/semantic-model/program");

var _scope = require("../../../lib/semantic-model/scope");

var _types = require("../../../lib/semantic-model/types");

var _symbol = require("../../../lib/semantic-model/symbol");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

describe("CallExpressionRefinementRule", function () {
	let context, rule, program, typeInferenceAnalysis;

	beforeEach(function () {
		program = new _program.Program();
		typeInferenceAnalysis = { analyse: _sinon2.default.stub(), infer: _sinon2.default.stub(), unify: _sinon2.default.stub() };
		context = new _hindleyMilnerContext.HindleyMilnerContext(typeInferenceAnalysis, new _typeInferenceContext.TypeInferenceContext(program));
		rule = new _callExpressionRefinementRule.CallExpressionRefinementRule();
	});

	describe("canRefine", function () {
		it("returns for a call expression", function () {
			// arrange
			const node = t.callExpression(t.identifier("log"), []);

			// act, assert
			(0, _chai.expect)(rule.canRefine(node)).to.be.true;
		});

		it("returns false otherwise", function () {
			(0, _chai.expect)(rule.canRefine(t.identifier("x"))).to.be.false;
		});
	});

	describe("refine", function () {
		describe("function with declaration", function () {
			it("returns the return type of the called function", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());

				const logTypeEnvironment = context.typeEnvironment.setType(_symbol.Symbol.RETURN, _types.VoidType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, logTypeEnvironment]]));

				// assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.VoidType);
			});

			it("returns void if the called function is void", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, context.typeEnvironment.setType(_symbol.Symbol.RETURN, _types.VoidType.create())]]));

				// assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.VoidType);
			});

			it("returns the type of the body of the arrow function if the body is an expression", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), []);
				const declaration = t.arrowFunctionExpression([], t.identifier("x"));
				declaration.expression = true;
				declaration.scope = new _scope.Scope();
				declaration.scope.addSymbol(new _symbol.Symbol("this", _symbol.SymbolFlags.Variable));

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), declaration));
				typeInferenceAnalysis.infer.withArgs(declaration.body).returns(_types.StringType.create());

				// assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.StringType);
			});

			it("returns any if the called function any", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(_types.AnyType.create());

				// assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.AnyType);
			});

			it("sets this to void if the callee is not a member expression", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, _typeEnvironment.TypeEnvironment.EMPTY]]));

				// act
				rule.refine(callExpression, context);

				// assert
				const analyseCall = typeInferenceAnalysis.analyse.getCall(0);
				const analyseTypeEnv = analyseCall.args[1];
				const thiz = logDeclaration.scope.resolveSymbol("this");

				(0, _chai.expect)(analyseTypeEnv.getType(thiz)).to.be.instanceOf(_types.VoidType);
			});

			it("sets this to the object of the callee, if the callee is a member expression", function () {
				// arrange
				const personNode = t.identifier("person");
				const logMember = t.memberExpression(personNode, t.identifier("log"));
				const callExpression = t.callExpression(logMember, [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				const log = new _symbol.Symbol("log", _symbol.SymbolFlags.Function & _symbol.SymbolFlags.Property);
				const personType = _types.ObjectType.create([[log, new _types.FunctionType(new _types.TypeVariable(), [], _types.VoidType.create(), logDeclaration)]]);

				typeInferenceAnalysis.infer.withArgs(personNode).returns(personType);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, _typeEnvironment.TypeEnvironment.EMPTY]]));

				_sinon2.default.stub(context, "getObjectType").withArgs(logMember).returns(personType);

				// act
				rule.refine(callExpression, context);

				// assert
				const analyseCall = typeInferenceAnalysis.analyse.getCall(0);
				const analyseTypeEnv = analyseCall.args[1];
				const thiz = logDeclaration.scope.resolveSymbol("this");

				(0, _chai.expect)(analyseTypeEnv.getType(thiz)).to.be.equals(personType);
			});

			// a function passed as callback is triggered in a different context then where it has been declared
			// But the function needs to have access to the symbols from the declaration context
			// therefor, the call context needs to be merged with the declaration context
			it("adds type mappings from the function declaration context to the call context", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable); // variable from the declaration scope
				const logType = new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration);
				logType.typeEnvironment = _typeEnvironment.TypeEnvironment.EMPTY.setType(x, _types.StringType.create());

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(logType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, _typeEnvironment.TypeEnvironment.EMPTY]]));

				// act
				rule.refine(callExpression, context);

				// assert
				const analyseCall = typeInferenceAnalysis.analyse.getCall(0);
				const analyseTypeEnv = analyseCall.args[1];

				(0, _chai.expect)(analyseTypeEnv.getType(x)).to.be.instanceOf(_types.StringType);
			});

			// E.g. if the function changes a variable in the callers context, then the type of the variable is changed after the call
			// e.g. let x = null; function init() { x = 10; }; init(); After the init call, x needs to be number
			it("updates changes types in the caller's context", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable); // variable from the callers scope that is visible in the called function
				const logType = new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration);
				context.setType(x, _types.TypeVariable.create());

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(logType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());
				// The type of x has changed during the function execution. The change needs to be reflected to the callers context
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, context.typeEnvironment.setType(x, _types.StringType.create())]]));

				// act
				rule.refine(callExpression, context);

				// assert
				(0, _chai.expect)(context.getType(x)).to.be.instanceOf(_types.StringType);
			});

			describe("function parameters", function () {
				it("assigns the types of the arguments to the parameters", function () {
					// arrange
					const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
					const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

					const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
					const mType = _types.StringType.create();
					program.symbolTable.setSymbol(logDeclaration.params[0], m);

					typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
					typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(mType);
					typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, _typeEnvironment.TypeEnvironment.EMPTY]]));

					// act
					rule.refine(callExpression, context);

					// assert
					const analyseCall = typeInferenceAnalysis.analyse.getCall(0);
					const analyseTypeEnv = analyseCall.args[1];

					(0, _chai.expect)(analyseTypeEnv.getType(m)).to.be.equal(mType);
				});

				it("assigns void to missing parameters", function () {
					// arrange
					const callExpression = t.callExpression(t.identifier("log"), []);
					const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

					const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(logDeclaration.params[0], m);

					typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
					typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, _typeEnvironment.TypeEnvironment.EMPTY]]));

					// act
					rule.refine(callExpression, context);

					// assert
					const analyseCall = typeInferenceAnalysis.analyse.getCall(0);
					const analyseTypeEnv = analyseCall.args[1];

					(0, _chai.expect)(analyseTypeEnv.getType(m)).to.be.instanceOf(_types.VoidType);
				});

				it("ignores unused arguments", function () {
					// arrange
					const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
					const logDeclaration = functionDeclaration(t.identifier("log"));

					typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(new _types.TypeVariable(), [], _types.VoidType.create(), logDeclaration));
					typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returnsArg(1);

					// act
					(0, _chai.expect)(() => rule.refine(callExpression, context)).not.to.throw;
				});

				// Caller passes an object to the function, the function adds new properties.
				// the new properties should be reflected to the call side
				it("updates the types of objects when they have been passed as arguments", function () {
					// arrange
					const personExpression = t.identifier("person");
					const callExpression = t.callExpression(t.identifier("setName"), [personExpression]);
					const setNameDeclaration = functionDeclaration(t.identifier("setName"), t.identifier("person")); // body is p.name = 'Test'

					const person = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(personExpression, person);
					const personType = _types.ObjectType.create();
					context.setType(person, personType);

					const personParameter = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(setNameDeclaration.params[0], personParameter);

					const setNameType = new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), setNameDeclaration);

					typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(setNameType);
					typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(personType);

					// a property name is added in the called function to the person object
					typeInferenceAnalysis.analyse = (node, typeEnvironment) => new Map([[null, typeEnvironment.substitute(personType, personType.addProperty(new _symbol.Symbol("name"), _types.StringType.create()))]]);

					// act
					rule.refine(callExpression, context);

					// assert
					(0, _chai.expect)(context.getType(person)).to.be.instanceOf(_types.ObjectType);
					(0, _chai.expect)(context.getType(person).getType(new _symbol.Symbol("name"))).to.be.instanceOf(_types.StringType);
				});

				// caller passes an object to the function. The function reassigns a new object to the parameter variable
				// this change should not be reflected to the call site.
				it("does not update an object property type if the variable has been reassigned in the function call", function () {
					// arrange
					const personExpression = t.identifier("person");
					const callExpression = t.callExpression(t.identifier("setName"), [personExpression]);
					const setNameDeclaration = functionDeclaration(t.identifier("setName"), t.identifier("person")); // body is p = { name: 'Test' }

					const person = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(personExpression, person);
					const personType = _types.ObjectType.create();
					context.setType(person, personType);

					const personParameter = new _symbol.Symbol("person", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(setNameDeclaration.params[0], personParameter);

					const setNameType = new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), setNameDeclaration);

					typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(setNameType);
					typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(personType);

					// a property name is added in the called function to the person object
					typeInferenceAnalysis.analyse = (node, typeEnvironment) => new Map([[null, typeEnvironment.setType(personParameter, _types.ObjectType.create([[new _symbol.Symbol("name"), _types.StringType.create()]]))]]);

					// act
					rule.refine(callExpression, context);

					// assert
					(0, _chai.expect)(context.getType(person)).to.be.instanceOf(_types.ObjectType);
					(0, _chai.expect)(context.getType(person).getType(new _symbol.Symbol("name"))).to.be.undefined;
				});
			});

			describe("recursion", function () {
				it("terminates recursive calls after 20 rounds", function () {
					this.timeout(5000);

					// arrange
					const func = functionDeclaration(t.identifier("f"));

					const c1 = t.callExpression(t.identifier("f"), []);
					const calls = [];
					let args = [];

					// create an array with 1000 call expressions. It simulates a function where the body always adds one more
					// argument and calls itself again.
					for (let i = 0; i < 1000; ++i) {
						args = args.concat(t.numericLiteral(i));
						calls.push(t.callExpression(t.identifier("f"), args));
					}

					const functionType = new _types.FunctionType(new _types.TypeVariable(), [], _types.VoidType.create(), func);
					for (const call of calls.concat(c1)) {
						typeInferenceAnalysis.infer.withArgs(call.callee).returns(functionType);
					}

					let nextCall = 0;
					typeInferenceAnalysis.analyse = (node, typeEnvironment) => {
						if (nextCall > 20) {
							_chai.expect.fail("Recursive function is called more then twenty times, should terminate after 20 calls");
						}

						rule.refine(calls[nextCall++], context);

						return new Map([[null, typeEnvironment]]);
					};

					typeInferenceAnalysis.infer.returns(_types.NumberType.create());

					// act
					rule.refine(c1, context);
				});

				it("detects recursive calls with the same arguments and uses the return type of the previously called function", function () {
					// arrange
					const func = functionDeclaration(t.identifier("successor"), t.identifier("x"));
					const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
					program.symbolTable.setSymbol(func.params[0], x);

					const funcT = new _types.FunctionType(new _types.TypeVariable(), [], _types.VoidType.create(), func);

					const call = t.callExpression(t.identifier("successor"), [t.numericLiteral(4)]);
					typeInferenceAnalysis.infer.withArgs(call.callee).returns(funcT);

					let analyseCount = 0;
					typeInferenceAnalysis.analyse = (node, typeEnvironment) => {
						++analyseCount;
						const recursiveCall = t.callExpression(t.identifier("successor"), [t.binaryExpression("-", t.identifier("x"), t.numericLiteral(-1))]);
						typeInferenceAnalysis.infer.withArgs(recursiveCall.callee).returns(funcT);
						program.symbolTable.setSymbol(recursiveCall.arguments[0].left, x);
						rule.refine(recursiveCall, context);

						return new Map([[null, typeEnvironment.setType(_symbol.Symbol.RETURN, _types.NumberType.create())]]);
					};

					typeInferenceAnalysis.infer.returns(_types.NumberType.create());

					// act
					(0, _chai.expect)(rule.refine(call, context)).to.be.instanceOf(_types.NumberType);
					(0, _chai.expect)(analyseCount).to.equals(1);
				});
			});
		});

		describe("external defined function", function () {
			it("infers the return type from the function signature", function () {
				// arrange
				const trimType = new _types.FunctionType(_types.VoidType.create(), [], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("trim"), []);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(trimType);

				// act, assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.StringType);
			});

			it("throws if the this type of the called function is not a subtype of the this expected by the function", function () {
				// arrange
				const trimType = new _types.FunctionType(_types.StringType.create(), [], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("trim"), []);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(trimType);

				// act, assert
				(0, _chai.expect)(() => rule.refine(callExpression, context)).to.throw("Type inference failure: The function cannot be called with this of type 'undefined' whereas 'string' is required.");
			});

			it("throws if the call misses required arguments", function () {
				// arrange
				const includesType = new _types.FunctionType(_types.VoidType.create(), [_types.StringType.create()], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("includes"), []);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(includesType);

				// act, assert
				(0, _chai.expect)(() => rule.refine(callExpression, context)).to.throw("Type inference failure: The argument 1 with type 'undefined' is not a subtype of the required parameter type 'string'.");
			});

			it("throws if a call parameter is not a subtype of the parameter type", function () {
				// arrange
				const substringType = new _types.FunctionType(_types.VoidType.create(), [_types.NumberType.create()], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("includes"), [t.identifier("x")]);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(substringType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.MaybeType.of(_types.NumberType.create()));
				typeInferenceAnalysis.unify.withArgs(_sinon2.default.match.instanceOf(_types.MaybeType), _sinon2.default.match.instanceOf(_types.NumberType)).returns(_types.MaybeType.of(_types.NumberType.create()));

				// act, assert
				(0, _chai.expect)(() => rule.refine(callExpression, context)).to.throw("Type inference failure: The argument 1 with type 'Maybe<number>' is not a subtype of the required parameter type 'number'.");
			});

			// if an argument is a type variable, then a unification is needed to get it's type
			it("unifies the argument with the expected parameter type", function () {
				// arrange
				const substringType = new _types.FunctionType(_types.VoidType.create(), [_types.NumberType.create()], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("substring"), [t.identifier("x")]);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(substringType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.TypeVariable.create());
				typeInferenceAnalysis.unify.returns(_types.NumberType.create());

				// act
				rule.refine(callExpression, context);

				// assert
				_sinon2.default.assert.calledWith(typeInferenceAnalysis.unify, _sinon2.default.match.instanceOf(_types.TypeVariable), _sinon2.default.match.instanceOf(_types.NumberType));
			});

			it("can call a function with missing optional arguments", function () {
				// arrange
				const substringType = new _types.FunctionType(_types.VoidType.create(), [_types.NumberType.create(), _types.MaybeType.of(_types.NumberType.create())], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("substring"), [t.numericLiteral(5)]);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(substringType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.NumberType.create());
				typeInferenceAnalysis.unify.withArgs(_sinon2.default.match.instanceOf(_types.NumberType), _sinon2.default.match.instanceOf(_types.NumberType)).returns(_types.NumberType.create());

				// act, assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.StringType);
			});

			it("can call a function with matching arguments", function () {
				// arrange
				const substringType = new _types.FunctionType(_types.VoidType.create(), [_types.NumberType.create(), _types.MaybeType.of(_types.NumberType.create())], _types.StringType.create());
				const callExpression = t.callExpression(t.identifier("substring"), [t.numericLiteral(5), t.numericLiteral(8)]);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(substringType);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.NumberType.create());
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[1]).returns(_types.NumberType.create());
				typeInferenceAnalysis.unify.returns(_types.NumberType.create());

				// act, assert
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.StringType);
			});

			it("analyses the body of a callback that has been passed as argument", function () {
				// arrange
				const predicateDeclaration = functionDeclaration(t.identifier("isEven"), t.identifier("x")); // body x % 2 === 0;
				const predicate = new _types.FunctionType(_types.VoidType.create(), [_types.TypeVariable.create()], _types.TypeVariable.create(), predicateDeclaration);
				const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(predicateDeclaration.params[0], x);

				const elementType = _types.TypeVariable.create();
				const predicateExpectedSignature = new _types.FunctionType(_types.VoidType.create(), [elementType], _types.BooleanType.create());
				const filter = new _types.FunctionType(_types.VoidType.create(), [_types.ArrayType.of(elementType), predicateExpectedSignature], _types.ArrayType.of(elementType));
				const callExpression = t.callExpression(t.identifier("filter"), [t.arrayExpression([t.numericLiteral(1), t.numericLiteral(2)]), t.identifier("isEven")]);

				const callContext = context.fresh();
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(filter);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.ArrayType.of(_types.NumberType.create()));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[1]).returns(predicate);
				_sinon2.default.stub(context, "fresh").returns(callContext);
				_sinon2.default.stub(context, "unify").returnsArg(0); // return the actual argument type

				// unifying the parameter with the argument type requires that the type variables in the parameter type are substituted
				callContext.unify = (t1, t2) => {
					if (t1 instanceof _types.ArrayType && t1.of instanceof _types.NumberType && t2 instanceof _types.ArrayType && t2.of instanceof _types.TypeVariable) {
						callContext.substitute(t2.of, t1.of);
						return t2;
					}
				};

				// Fake analysis of the predicate function by setting the return type
				callContext.analyse = () => callContext.typeEnvironment = callContext.typeEnvironment.setType(_symbol.Symbol.RETURN, _types.BooleanType.create());

				// expect
				(0, _chai.expect)(rule.refine(callExpression, context)).to.be.instanceOf(_types.ArrayType).and.to.have.property("of").that.is.an.instanceOf(_types.NumberType);
			});

			it("it throws if the return type of the callback is not a subtype of the expected return type for the callback", function () {
				// arrange
				const predicateDeclaration = functionDeclaration(t.identifier("isEven"), t.identifier("x")); // body return null;
				const predicate = new _types.FunctionType(_types.VoidType.create(), [_types.TypeVariable.create()], _types.TypeVariable.create(), predicateDeclaration);
				const x = new _symbol.Symbol("x", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(predicateDeclaration.params[0], x);

				const elementType = _types.TypeVariable.create();
				const predicateExpectedSignature = new _types.FunctionType(_types.VoidType.create(), [elementType], elementType);
				const filter = new _types.FunctionType(_types.VoidType.create(), [_types.ArrayType.of(elementType), predicateExpectedSignature], _types.ArrayType.of(elementType));
				const callExpression = t.callExpression(t.identifier("map"), [t.arrayExpression([t.numericLiteral(1), t.numericLiteral(2)]), t.identifier("isEven")]);

				const callContext = context.fresh();
				_sinon2.default.stub(context, "fresh").returns(callContext);

				// unifying the parameter with the argument type requires that the type variables in the parameter type are substituted
				callContext.unify = (t1, t2) => {
					if (t1 instanceof _types.ArrayType && t1.of instanceof _types.NumberType && t2 instanceof _types.ArrayType && t2.of instanceof _types.TypeVariable) {
						callContext.substitute(t2.of, t1.of);
						return t2;
					}

					if (t1 instanceof _types.NumberType && t2 instanceof _types.NullType) {
						return _types.MaybeType.of(t1);
					}
				};

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(filter);
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.ArrayType.of(_types.NumberType.create()));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[1]).returns(predicate);
				typeInferenceAnalysis.unify.returnsArg(0); // return the actual argument type

				// Fake analysis of the predicate function by setting the return type
				callContext.analyse = () => callContext.typeEnvironment = callContext.typeEnvironment.setType(_symbol.Symbol.RETURN, _types.NullType.create());

				// expect
				(0, _chai.expect)(() => rule.refine(callExpression, context)).to.throw("Type inference failure: The return type 'null' of the callback is not a subtype of the return type 'number' of the expected callback.");
			});
		});

		describe("called function", function () {
			it("is the inferred function of the callee", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				const logDeclaration = functionDeclaration(t.identifier("log"), t.identifier("m"));

				const m = new _symbol.Symbol("m", _symbol.SymbolFlags.Variable);
				program.symbolTable.setSymbol(logDeclaration.params[0], m);

				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(new _types.FunctionType(_types.TypeVariable.create(), [_types.TypeVariable.create()], _types.VoidType.create(), logDeclaration));
				typeInferenceAnalysis.infer.withArgs(callExpression.arguments[0]).returns(_types.StringType.create());

				const logTypeEnvironment = context.typeEnvironment.setType(_symbol.Symbol.RETURN, _types.VoidType.create());
				typeInferenceAnalysis.analyse.withArgs(logDeclaration.body).returns(new Map([[null, logTypeEnvironment]]));

				// act
				rule.refine(callExpression, context);

				// assert
				_sinon2.default.assert.calledWith(typeInferenceAnalysis.analyse, logDeclaration.body);
			});

			it("throws if the type is not a function type", function () {
				// arrange
				const callExpression = t.callExpression(t.identifier("log"), [t.stringLiteral("Hy")]);
				typeInferenceAnalysis.infer.withArgs(callExpression.callee).returns(_types.StringType.create());

				// act, assert
				(0, _chai.expect)(() => rule.refine(callExpression, context)).to.throw("Type inference failure: Cannot invoke the non function type string.");
			});
		});
	});

	function functionDeclaration(identifier) {
		for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			params[_key - 1] = arguments[_key];
		}

		const declaration = t.functionDeclaration(identifier, params, t.blockStatement([]));
		declaration.scope = new _scope.Scope();
		declaration.scope.addSymbol(new _symbol.Symbol("this", _symbol.SymbolFlags.Variable));
		return declaration;
	}
});
//# sourceMappingURL=call-expression-refinement-rule.spec.js.map
